# Collision Push Mechanic Analysis

## Current implementation overview
- **Entry point for sprite impacts:** `resolveSpriteInteractionsInSeg` applies `applyImpactPushToSprite` when the player overlaps impactable sprites, which seeds `impactState` on the sprite and uses `computeCollisionPush` to populate forward and lateral velocities.【F:src/gameplay.js†L717-L759】【F:src/gameplay.js†L326-L345】
- **Entry point for NPC impacts:** `resolveCarCollisionsInSeg` triggers when the player overlaps an NPC hitbox, rewinds the player a bit, and calls `applyNpcCollisionPush`. The push velocity is again produced by `computeCollisionPush` using the player's current forward speed.【F:src/gameplay.js†L760-L816】【F:src/gameplay.js†L399-L416】
- **Push application:** Both sprites and cars consume the stored `lateralVel`/`forwardVel` for up to `COLLISION_PUSH_DURATION` seconds. Cars add the push to their regular per-frame travel, while sprites advance their `s` position by the push amount each update.【F:src/gameplay.js†L344-L371】【F:src/gameplay.js†L1185-L1210】

## Why the current tuning misbehaves
- `computeCollisionPush` multiplies the player's instantaneous tangential speed by `COLLISION_PUSH_SPEED_MULTIPLIER`. With the default tuning (`topSpeed = 7000`, multiplier `1.25`), the generated push speed easily exceeds 8000 units/s.【F:src/config.js†L7-L24】【F:src/gameplay.js†L293-L315】
- The push velocities are expressed in world-space track units, but they are applied directly to normalized lane offsets (`[-1, 1]`). Because the road width is not considered, a single frame at 60 Hz adds ~133 units of lateral displacement (8000 × 0.016). That immediately clamps the target to the road edge, which looks like the object explodes sideways.【F:src/gameplay.js†L344-L356】【F:src/gameplay.js†L1185-L1197】
- Forward push suffers from the same scale mismatch. At 8000 units/s sustained for the default 0.45 s duration, the target travels ~3600 units, i.e. ~18 segments (segment length 200). This creates the “shooting objects away” behaviour unless the multiplier is reduced to something like 0.0005.【F:src/gameplay.js†L298-L315】【F:src/gameplay.js†L1185-L1197】
- Because the multiplier has to be reduced drastically to avoid explosions, the forward impulse becomes negligible. After clamping the multiplier to ~0.0005, the total forward displacement over 0.45 s is only ~3.5 units, which is imperceptible compared to normal NPC motion (~500–1500 units/s). This is why the push no longer nudges sprites or cars forward.【F:src/gameplay.js†L298-L315】【F:src/gameplay.js†L1185-L1208】

## Recommended simplifications
1. **Base the push on relative speed, not absolute speed.** Compute the difference between the player's forward speed and the target's forward speed (zero for static sprites). Using the excess speed avoids coupling the impulse to the global speed scale and keeps low-speed bumps from over-pushing.【F:src/gameplay.js†L780-L803】
2. **Cap the forward displacement in track space.** Decide on a maximum number of segments we are willing to move an object (e.g. 0.5–1.0 segment) and derive the velocity cap as `maxForwardVel = (segmentLength * maxSegmentsToMove) / COLLISION_PUSH_DURATION`. Clamp the forward push to that value so even at extreme speed the object only surges a short distance.【F:src/gameplay.js†L128-L135】【F:src/gameplay.js†L1185-L1210】
3. **Convert lateral push into lane-normalized units.** Instead of reusing the forward speed, pick a fixed separation goal (e.g. move half a lane over the push duration). Compute `lateralVel = desiredLateralSeparation / COLLISION_PUSH_DURATION` with the direction derived from the offset delta. This keeps lateral motion smooth and independent of the track’s physical width.【F:src/gameplay.js†L302-L314】【F:src/gameplay.js†L1185-L1197】
4. **Expose small tuning constants.** Replace `COLLISION_PUSH_SPEED_MULTIPLIER` with intuitive parameters like `COLLISION_PUSH_FORWARD_SEGMENTS` and `COLLISION_PUSH_LATERAL_LANES`, making the mechanic easier to tweak without understanding raw speed units.【F:src/gameplay.js†L128-L135】【F:src/gameplay.js†L298-L315】
5. **Future refinement (optional):** Provide target width information to `computeCollisionPush` so we can guarantee post-collision separation that clears the player and respects guard rails, but this is not required for the simplified pass.

Applying the steps above yields a predictable push: low-speed taps create gentle nudges, high-speed hits stay bounded, and the tweakable constants map directly to observable motion instead of engine-specific units.
