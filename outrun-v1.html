<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Straight Track — 2.5D + Drift + Fog + Cliffs + Sprites + Guardrails</title>
<style>
  html,body{margin:0;background:#0f1a0f}
  .wrap{display:flex;gap:16px;justify-content:center;align-items:center;height:100vh}
  .stack{position:relative;width:1024px;height:768px;border:1px solid #2a2a2a;background:#ffffff}
  #outrun{position:absolute;left:0;top:0;width:1024px;height:768px;image-rendering:pixelated;image-rendering:crisp-edges;background:#ffffff}
  #sideOverlay{position:absolute;left:0;top:0;width:1024px;height:768px;background:transparent;pointer-events:none}
  #hudMatte{position:absolute;left:0;top:0;width:1024px;height:768px;image-rendering:pixelated;image-rendering:crisp-edges;background:transparent;pointer-events:none}
  .ui{position:fixed;left:50%;top:10px;transform:translateX(-50%);font:12px system-ui,Arial;background:#000c;color:#fff;padding:6px 10px;border-radius:10px}
</style>

<div class="wrap">
  <div class="stack">
    <canvas id="outrun" width="512" height="384" title="2.5D view (WebGL)"></canvas>
    <canvas id="sideOverlay" width="1024" height="768" title="Side overlay (B to toggle)"></canvas>
    <canvas id="hudMatte" width="512" height="384" title="HUD reset matte"></canvas>
  </div>
</div>
<div class="ui">←/→ steer · ↑ throttle · ↓ brake · SPACE hop (hold to drift) · R reset · B toggle overlay</div>

<script>
(() => {
  // ---------- Tunables ----------
  const TUNE_PLAYER = {
    accel: 3000,
    brake: 3000,
    maxSpeed: 7000,
    gravity: 6400,
    rollFriction: 0.3,
    airDrag: 0,
    steerBase: 2.0,
    leanCentrifugal: 0.1,
    hopImpulse: 1400,
    hopCooldown: 0.25,
    crestBoostMultiplier: 1.25,
    playerScale: 1.00,
  };

  // ---------- Road tiling/subdivision tunables ----------
  const ROAD_COLS_NEAR = 6;   // max columns when wide/near
  const ROAD_COLS_FAR  = 2;   // min columns when narrow/far
  const COL_PX_TARGET  = 96;  // aim ~this many pixels per column (near end)
  const ROW_PX_TARGET  = 18;  // aim ~this many pixels of vertical height per row
  const ROW_MAX        = 64;  // safety cap

  const TUNE_TRACK = {
    segmentLength: 200,
    roadWidth: 2400,
    drawDistance: 200,
    fov: 140,
    cameraHeight: 700,
    camBackSegments: 2,
    camYTau: 0.1,

    // push back from cliffs
    cliffPush: 0.5,

    // rails (world-space short walls)
    railInset: 0.95,       // 0..1 from road center to edge (inner face position)
    wallShortLeft:  400,   // world units tall (left rail)
    wallShortRight: 400,   // world units tall (right rail)

    // overlay sampling scale
    MPerPxX: 8,
    MPerPxY: 40,
  };

  const CLIFF_PUSH = { distanceGain: 0.6, capPerFrame: 0.5 };
  const CLIFF_CAMERA_FRACTION = 1 / 3;
  const FAILSAFE   = { belowRoadUnits: 600 };

  const FOG = {
    enabled: true,
    nearSegs: 0,
    farSegs: 160,
    color: [0.1, 0.5, 0.8],
  };

  const DEFAULT_COLORS = {
    road: [0.5, 0.5, 0.5, 1],
    wall: [0.5, 0.5, 0.5, 1],
    rail: [0.5, 0.5, 0.5, 1],
  };

  // DEBUG fill mode for road & cliffs (alternating colors)
  const DEBUG = { mode: 'off', span: 3, colors: { a:[1,1,1,1], b:[0.82,0.90,1,1] } };

  const SPRITE_FAR = { shrinkTo: 0.1, power: 0.4 };

  // Parallax layers (path names come from asset manifest below)
  const PARALLAX_LAYERS = [
    { key:'horizon1', parallaxX: 0.05, uvSpanX: 1.0, uvSpanY: 1.0 },
    { key:'horizon2', parallaxX: 0.10, uvSpanX: 1.0, uvSpanY: 1.0 },
    { key:'horizon3', parallaxX: 0.18, uvSpanX: 1.0, uvSpanY: 1.0 },
  ];

  // Drift / boost settings
  const DRIFT = {
    boostChargeMin: 0.60,
    boostTime: 0.35,
    boostMult: 1.8,
    boostSteerScale: 0.6,
    boostLockBase: 0.75,
    boostLockWith: 1.25,
    boostLockAgainst: 0.25
  };

  const BOOST_ZONE_TYPES = { JUMP: 'jump', DRIVE: 'drive' };
  const BOOST_ZONE_FALLBACK_COLOR = {
    fill: 'rgba(255,255,255,0.2)',
    stroke: '#fafafa',
    solid: [1, 1, 1, 0.35],
  };
  const BOOST_ZONE_COLORS = {
    [BOOST_ZONE_TYPES.JUMP]: {
      fill: 'rgba(255,152,0,0.45)',
      stroke: '#ff9800',
      solid: [1, 152/255, 0, 0.45],
    },
    [BOOST_ZONE_TYPES.DRIVE]: {
      fill: 'rgba(33,150,243,0.45)',
      stroke: '#2196f3',
      solid: [33/255, 150/255, 243/255, 0.45],
    },
  };
  const BOOST_LANE_LIMITS = { MIN: -1, MAX: 1 };
  const ROAD_LANE_LIMITS = { MIN: -2, MAX: 2 };
  const clampBoostLane = (v) => {
    if (v == null) return v;
    const min = BOOST_LANE_LIMITS.MIN;
    const max = BOOST_LANE_LIMITS.MAX;
    if (v < min) return min;
    if (v > max) return max;
    return v;
  };
  const clampRoadLane = (v, fallback = 0) => {
    if (v == null) return fallback;
    const min = ROAD_LANE_LIMITS.MIN;
    const max = ROAD_LANE_LIMITS.MAX;
    if (v < min) return min;
    if (v > max) return max;
    return v;
  };
  const laneToCenterOffset = (n, fallback = 0) => clampRoadLane(n, fallback) * 0.5;
  const laneToRoadRatio = (n, fallback = 0) => {
    const clamped = clampRoadLane(n, fallback);
    return (clamped - ROAD_LANE_LIMITS.MIN) / (ROAD_LANE_LIMITS.MAX - ROAD_LANE_LIMITS.MIN);
  };
  function parseBoostZoneType(raw) {
    if (raw == null) return null;
    const norm = raw.toString().trim().toLowerCase();
    if (!norm) return null;
    if (['jump', 'orange', 'crest', 'air'].includes(norm)) return BOOST_ZONE_TYPES.JUMP;
    if (['drive', 'ground', 'auto', 'blue'].includes(norm)) return BOOST_ZONE_TYPES.DRIVE;
    return null;
  }
  function parseBoostLaneValue(raw) {
    if (raw == null || raw === '') return null;
    const num = Number.parseFloat(raw);
    if (!Number.isFinite(num)) return null;
    const min = BOOST_LANE_LIMITS.MIN;
    const max = BOOST_LANE_LIMITS.MAX;
    if (num < min) return min;
    if (num > max) return max;
    return num;
  }

  // Tilt config
  const cfgTilt = { tiltMaxDeg: 45, tiltSens: -3, tiltCurveWeight: -.2, tiltEase: 0.08, tiltDir: 1 };
  let camRollDeg = 0, playerTiltDeg = 0, prevPlayerN = 0, lateralRate = 0;

  const cfgTiltAdd = { tiltAddEnabled: true, tiltAddMaxDeg: 10 };

  // ---------- Canvas / GL ----------
  const c3D   = document.getElementById('outrun');
  const W = c3D.width, H = c3D.height;
  const HALF_VIEW = W * 0.5;

  const cSide = document.getElementById('sideOverlay');
  const ctxSide = cSide.getContext('2d', { alpha:true });
  const SW = cSide.width, SH = cSide.height;

  const cHUD = document.getElementById('hudMatte');
  const ctxHUD = cHUD.getContext('2d', { alpha:true });
  const HUD_W = cHUD.width, HUD_H = cHUD.height;
  const HUD_COVER_RADIUS = Math.hypot(HUD_W, HUD_H) * 0.5 + 2;

  let overlayOn = true;
  const setOverlay = v => { overlayOn = v; cSide.style.display = overlayOn ? 'block' : 'none'; };
  setOverlay(true);
  addEventListener('keydown',e=>{ if(e.code==='KeyB') setOverlay(!overlayOn); });
  addEventListener('keydown',e=>{ if(e.code==='KeyL') resetScene().catch(err=>console.error(err)); });

  class GLRenderer {
    constructor(canvas) {
      const gl = canvas.getContext('webgl', { alpha:false, antialias:false, premultipliedAlpha:false });
      if (!gl) throw new Error('WebGL not available');
      this.gl = gl;
      const vsSrc = `
        attribute vec2 a_pos;
        attribute vec2 a_uv;
        attribute vec4 a_color;
        attribute float a_fog;
        uniform vec2  u_viewSize;
        uniform float u_roll;
        uniform vec2  u_pivot;
        varying vec2 v_uv;
        varying vec4 v_color;
        varying float v_fog;
        void main(){
          vec2 p = a_pos - u_pivot;
          float s = sin(u_roll), c = cos(u_roll);
          p = vec2(c*p.x - s*p.y, s*p.x + c*p.y) + u_pivot;
          vec2 clip = vec2((p.x/u_viewSize.x)*2.0 - 1.0,
                           1.0 - (p.y/u_viewSize.y)*2.0);
          gl_Position = vec4(clip,0.0,1.0);
          v_uv = a_uv; v_color = a_color; v_fog = a_fog;
        }`;
      const fsSrc = `
        precision mediump float;
        uniform sampler2D u_tex;
        uniform int u_useTex;
        uniform int u_fogEnabled;
        uniform vec3 u_fogColor;
        varying vec2 v_uv;
        varying vec4 v_color;
        varying float v_fog;
        void main(){
          vec4 base = (u_useTex==1)? texture2D(u_tex, v_uv) : vec4(1.0);
          vec4 shaded = vec4(base.rgb * v_color.rgb, base.a * v_color.a);
          if (u_fogEnabled == 1) {
            float f = clamp(v_fog, 0.0, 1.0);
            shaded.rgb = mix(shaded.rgb, u_fogColor, f);
          }
          gl_FragColor = shaded;
        }`;
      const prog = this._createProgram(vsSrc, fsSrc);
      gl.useProgram(prog);
      this.prog = prog;
      this.a_pos   = gl.getAttribLocation(prog, 'a_pos');
      this.a_uv    = gl.getAttribLocation(prog, 'a_uv');
      this.a_color = gl.getAttribLocation(prog, 'a_color');
      this.a_fog   = gl.getAttribLocation(prog, 'a_fog');
      this.u_viewSize   = gl.getUniformLocation(prog, 'u_viewSize');
      this.u_tex        = gl.getUniformLocation(prog, 'u_tex');
      this.u_useTex     = gl.getUniformLocation(prog, 'u_useTex');
      this.u_roll       = gl.getUniformLocation(prog, 'u_roll');
      this.u_pivot      = gl.getUniformLocation(prog, 'u_pivot');
      this.u_fogEnabled = gl.getUniformLocation(prog, 'u_fogEnabled');
      this.u_fogColor   = gl.getUniformLocation(prog, 'u_fogColor');

      // streaming slab
      this.vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
      gl.bufferData(gl.ARRAY_BUFFER, 54*4, gl.DYNAMIC_DRAW); // 6 verts * 9 floats * 4B
      const stride = 9*4;
      gl.enableVertexAttribArray(this.a_pos);
      gl.vertexAttribPointer(this.a_pos,2,gl.FLOAT,false,stride,0);
      gl.enableVertexAttribArray(this.a_uv);
      gl.vertexAttribPointer(this.a_uv,2,gl.FLOAT,false,stride,2*4);
      gl.enableVertexAttribArray(this.a_color);
      gl.vertexAttribPointer(this.a_color,4,gl.FLOAT,false,stride,4*4);
      gl.enableVertexAttribArray(this.a_fog);
      gl.vertexAttribPointer(this.a_fog,1,gl.FLOAT,false,stride,8*4);

      this.slab = new Float32Array(54);

      gl.viewport(0,0,canvas.width,canvas.height);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.uniform2f(this.u_viewSize, canvas.width, canvas.height);
      gl.uniform1i(this.u_tex, 0);
      gl.uniform1i(this.u_useTex, 0);

      // fog uniforms (dirty-checked later)
      this._fogEnabled = null;
      this._fogColor = [NaN,NaN,NaN];

      this.whiteTex = this._makeWhiteTex();
    }
    _createShader(src, type){
      const gl=this.gl, sh = gl.createShader(type);
      gl.shaderSource(sh, src); gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh)||'shader error');
      return sh;
    }
    _createProgram(vs, fs){
      const gl=this.gl, p=gl.createProgram();
      gl.attachShader(p, this._createShader(vs, gl.VERTEX_SHADER));
      gl.attachShader(p, this._createShader(fs, gl.FRAGMENT_SHADER));
      gl.linkProgram(p);
      if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)||'link error');
      return p;
    }
    _makeWhiteTex(){
      const gl=this.gl, t=gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, t);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255,255,255,255]));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      return t;
    }
    loadTexture(url){
      const gl=this.gl;
      return new Promise((resolve)=>{
        const img=new Image();
        img.crossOrigin = 'anonymous';
        img.onload=()=>{
          const t=gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D,t);
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false);
          gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          resolve(t);
        };
        img.onerror=()=>resolve(null);
        img.src=url;
      });
    }
    begin(clear=[0.9,0.95,1.0,1]){
      const gl=this.gl;
      gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
      gl.clearColor(clear[0],clear[1],clear[2],clear[3]); gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform2f(this.u_pivot, gl.canvas.width*0.5, gl.canvas.height*0.82);
      // Fog uniforms only when changed
      const en = (FOG.enabled?1:0);
      if (this._fogEnabled !== en) { this._fogEnabled = en; gl.uniform1i(this.u_fogEnabled, en); }
      const [r,g,b]=FOG.color;
      if (r!==this._fogColor[0] || g!==this._fogColor[1] || b!==this._fogColor[2]) {
        this._fogColor = [r,g,b];
        gl.uniform3f(this.u_fogColor, r, g, b);
      }
    }
    setRollPivot(rad, px, py){ const gl=this.gl; gl.uniform1f(this.u_roll, rad); gl.uniform2f(this.u_pivot, px, py); }
    drawQuadTextured(tex, quad, uv, tint=[1,1,1,1], fog=[0,0,0,0]){
      const v = this.slab;
      let i=0;
      // tri 1
      v[i++]=quad.x1; v[i++]=quad.y1; v[i++]=uv.u1; v[i++]=uv.v1; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[0];
      v[i++]=quad.x2; v[i++]=quad.y2; v[i++]=uv.u2; v[i++]=uv.v2; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[1];
      v[i++]=quad.x3; v[i++]=quad.y3; v[i++]=uv.u3; v[i++]=uv.v3; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[2];
      // tri 2
      v[i++]=quad.x1; v[i++]=quad.y1; v[i++]=uv.u1; v[i++]=uv.v1; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[0];
      v[i++]=quad.x3; v[i++]=quad.y3; v[i++]=uv.u3; v[i++]=uv.v3; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[2];
      v[i++]=quad.x4; v[i++]=quad.y4; v[i++]=uv.u4; v[i++]=uv.v4; v[i++]=tint[0]; v[i++]=tint[1]; v[i++]=tint[2]; v[i++]=tint[3]; v[i++]=fog[3];
      const gl=this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, v);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex || this.whiteTex);
      gl.uniform1i(this.u_useTex, tex ? 1 : 0);
      gl.drawArrays(gl.TRIANGLES,0,6);
    }
    drawQuadSolid(quad, color=[1,0,0,1], fog=[0,0,0,0]){
      const uv={u1:0,v1:0,u2:1,v2:0,u3:1,v3:1,u4:0,v4:1};
      this.drawQuadTextured(this.whiteTex, quad, uv, color, fog);
    }
    makeCircleTex(size=64){
      const cvs=document.createElement('canvas'); cvs.width=size; cvs.height=size;
      const ctx=cvs.getContext('2d');
      const cx=size/2, cy=size/2, r=size*0.45;
      const g=ctx.createRadialGradient(cx,cy,0, cx,cy,r);
      g.addColorStop(0.0,'rgba(255,255,255,1)');
      g.addColorStop(0.7,'rgba(255,255,255,1)');
      g.addColorStop(1.0,'rgba(255,255,255,0)');
      ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      const gl=this.gl, t=gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, t);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,cvs);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return t;
    }
    end(){}
  }
  const glr = new GLRenderer(c3D);

  // ---------- Assets: unified manifest & loader ----------
  const assetManifest = {
    road:      'tex/road-seg.png',
    rail:      'tex/guardrail.png',
    cliff:     'tex/cliff.png',
    boost:     'tex/boost.png',
    horizon1:  'tex/paralax-1.png',
    horizon2:  'tex/paralax-2.png',
    horizon3:  'tex/paralax-3.png',
    car:       'tex/car.png',
    semi:      'tex/semi.png',
    tree:      'tex/tree.png',
    sign:      'tex/billboard.png',
  };

  const textures = {};
  (async () => {
    await Promise.all(Object.entries(assetManifest).map(async ([k, path])=>{
      textures[k] = await glr.loadTexture(path);
    }));
  })().catch(()=>{ /* ignore */ });

  const TEX_PICKUP = glr.makeCircleTex(64);

  const SPRITE_META = {
    PLAYER: { wN: 0.16, aspect: 0.7,  tint:[0.90,0.22,0.21,1], tex:null },
    CAR:    { wN: 0.28, aspect: 0.7,  tint:[0.20,0.70,1.00,1],  tex:()=>textures.car  || null },
    SEMI:   { wN: 0.34, aspect: 1.60, tint:[0.85,0.85,0.85,1],  tex:()=>textures.semi || null },
    TREE:   { wN: 0.50, aspect: 3.00, tint:[0.22,0.70,0.22,1],  tex:()=>textures.tree || null },
    SIGN:   { wN: 0.55, aspect: 1.00, tint:[1.00,1.00,1.00,1],  tex:()=>textures.sign || null },
    PALM:   { wN: 0.38, aspect: 3.20, tint:[0.25,0.62,0.27,1],  tex:()=>textures.tree || null },
    PICKUP: { wN: 0.10, aspect: 1.00, tint:[1.00,0.92,0.20,1],  tex:()=>TEX_PICKUP    || null },
  };

  const getKindScale = (kind) => (kind === 'PLAYER' ? TUNE_PLAYER.playerScale : 1.0);

  // ---------- Track data & builder ----------
  const segmentLength = TUNE_TRACK.segmentLength;
  const roadWidthAt = (s) => TUNE_TRACK.roadWidth;

  let segments=[], trackLength=0;
  let boostZoneIdCounter = 0;

  // ---- Per-segment cliff series (filled after track build)
  const CLIFF_SERIES = {
    leftA:  { dx: [], dy: [] },
    leftB:  { dx: [], dy: [] },
    rightA: { dx: [], dy: [] },
    rightB: { dx: [], dy: [] },
  };
  let CLIFF_READY = false;

  function resetCliffSeries(){
    const n = segments.length;
    const clear = (arr)=>{ arr.length = n; for (let i=0;i<n;i++) arr[i] = 0; };

    clear(CLIFF_SERIES.leftA.dx);  clear(CLIFF_SERIES.leftA.dy);
    clear(CLIFF_SERIES.leftB.dx);  clear(CLIFF_SERIES.leftB.dy);
    clear(CLIFF_SERIES.rightA.dx); clear(CLIFF_SERIES.rightA.dy);
    clear(CLIFF_SERIES.rightB.dx); clear(CLIFF_SERIES.rightB.dy);

    CLIFF_READY = false;
  }

  function addSegment(curve, y, features = {}){
    const n=segments.length;
    const prevY = segments.length ? segments[n-1].p2.world.y : 0;
    const featureClone = { ...features };
    if (!('rail' in featureClone)) featureClone.rail = true;
    if (Array.isArray(featureClone.boostRange)) featureClone.boostRange = [...featureClone.boostRange];
    if (Array.isArray(featureClone.boostZones)) featureClone.boostZones = featureClone.boostZones.map(zone => ({ ...zone }));
    featureClone.boost = !!featureClone.boost;
    segments.push({
      index:n,
      curve,
      features: featureClone,
      p1:{ world:{ y: prevY, z:n*segmentLength }, camera:{}, screen:{} },
      p2:{ world:{ y:y,                                      z:(n+1)*segmentLength }, camera:{}, screen:{} },
      sprites:[], cars:[], pickups:[]
    });
  }

  const clamp01 = (t) => (t < 0 ? 0 : (t > 1 ? 1 : t));

  const easeLinear = (a,b,t)=> a + (b-a) * clamp01(t);
  const easeInQuad = (a,b,t)=> a + (b-a) * Math.pow(clamp01(t), 2);
  const easeOutQuad= (a,b,t)=> a + (b-a) * (1 - Math.pow(1 - clamp01(t), 2));
  const easeInCub  = (a,b,t)=> a + (b-a) * Math.pow(clamp01(t), 3);
  const easeOutCub = (a,b,t)=> a + (b-a) * (1 - Math.pow(1 - clamp01(t), 3));

  const easeInOutQuad01 = (t)=> (t<0.5)? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
  const easeInOutCub01  = (t)=> (t<0.5)? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;

  function getEase01(spec){
    const clamp01 = (x)=> x<0?0:x>1?1:x;
    const raw = (spec||'smooth:io').toLowerCase().trim();
    const [kind, modeRaw] = raw.split(':');
    const mode = (modeRaw||'io');
    const K = {
      linear: { in:(t)=>t, out:(t)=>t, io:(t)=>t },
      smooth: { in:(t)=>Math.pow(clamp01(t),2), out:(t)=>1-Math.pow(1-clamp01(t),2), io:easeInOutQuad01 },
      sharp:  { in:(t)=>Math.pow(clamp01(t),3), out:(t)=>1-Math.pow(1-clamp01(t),3), io:easeInOutCub01 },
    };
    return (K[kind]||K.smooth)[mode] || K.smooth.io;
  }

  const CURVE_EASE = {
    linear: { in: easeLinear,  out: easeLinear },
    smooth: { in: easeInQuad,  out: easeOutQuad },
    sharp:  { in: easeInCub,   out: easeOutCub },
  };

  const HEIGHT_EASE_UNIT = {
    linear: { in: (t)=> clamp01(t),          out: (t)=> clamp01(t) },
    smooth: { in: (t)=> Math.pow(clamp01(t),2),
              out:(t)=> 1 - Math.pow(1 - clamp01(t),2) },
    sharp:  { in: (t)=> Math.pow(clamp01(t),3),
              out:(t)=> 1 - Math.pow(1 - clamp01(t),3) },
  };

  function lastY(){
    return segments.length ? segments[segments.length-1].p2.world.y : 0;
  }

  function addRoad(enter, hold, leave, curve, dyInSegments = 0, elevationProfile = 'smooth', featurePayload = {}){
    const e = Math.max(0, enter|0), h = Math.max(0, hold|0), l = Math.max(0, leave|0);
    const total = e + h + l;
    if (total <= 0) return;

    const startY = lastY();
    const endY   = startY + (dyInSegments * segmentLength);
    const hasElevationChange = dyInSegments !== 0;
    const profile =
      elevationProfile === 'linear' ? 'linear' :
      elevationProfile === 'sharp'  ? 'sharp'  :
                                      'smooth';

    const extras = { ...featurePayload };
    const railPresent = ('rail' in extras) ? !!extras.rail : true;
    const boostRangeRaw = Array.isArray(extras.boostRange) ? extras.boostRange : null;
    const boostZonesRaw = Array.isArray(extras.boostZones)
      ? extras.boostZones.map(zone => ({ ...zone }))
      : null;
    delete extras.rail;
    delete extras.boostRange;
    delete extras.boostZones;

    let zoneSpecs = boostZonesRaw && boostZonesRaw.length ? boostZonesRaw : null;
    if ((!zoneSpecs || zoneSpecs.length === 0) && boostRangeRaw && boostRangeRaw.length >= 2) {
      const start = Math.floor(Math.max(0, boostRangeRaw[0]));
      const end = Math.floor(Math.max(start, boostRangeRaw[1]));
      if (!(start === 0 && end === 0)) {
        const fallbackStart = clampBoostLane(-2);
        const fallbackEnd = clampBoostLane(2);
        zoneSpecs = [{
          id: `legacy-${boostZoneIdCounter++}`,
          startOffset: start,
          endOffset: end,
          type: BOOST_ZONE_TYPES.JUMP,
          nStart: fallbackStart,
          nEnd: fallbackEnd,
          visible: true,
        }];
      }
    }

    const buildFeatures = (segOffset) => {
      const segFeatures = { ...extras, rail: railPresent };
      if (zoneSpecs && zoneSpecs.length) {
        const zonesForSeg = zoneSpecs
          .filter(zone => segOffset >= zone.startOffset && segOffset <= zone.endOffset)
          .map(zone => ({ ...zone }));
        if (zonesForSeg.length) {
          segFeatures.boostZones = zonesForSeg;
          const minStart = zonesForSeg.reduce((acc, zone) => Math.min(acc, zone.startOffset), Number.POSITIVE_INFINITY);
          const maxEnd = zonesForSeg.reduce((acc, zone) => Math.max(acc, zone.endOffset), Number.NEGATIVE_INFINITY);
          segFeatures.boostRange = [minStart, maxEnd];
          segFeatures.boost = true;
        } else {
          segFeatures.boost = false;
        }
      } else {
        segFeatures.boost = false;
      }
      return segFeatures;
    };

    let segOffset = 0;
    const computeY = (progressRaw) => {
      if (!hasElevationChange) return startY;

      // progressRaw is in [0..1] across (enter + hold + leave)
      const t = clamp01(progressRaw);

      // Breakpoint earlier if enter > leave, later if leave > enter.
      // Add small epsilons to avoid division-by-zero.
      const k = (e + 1e-6) / (e + l + 2e-6); // 0..1

      let shaped01;
      if (t < k) {
        // Left side (enter): use "in" easing
        const u = t / Math.max(k, 1e-6);
        shaped01 = 0.5 * HEIGHT_EASE_UNIT[profile].in(u); // scales left half to [0..0.5]
      } else {
        // Right side (leave): use "out" easing
        const u = (t - k) / Math.max(1 - k, 1e-6);
        shaped01 = 0.5 + 0.5 * HEIGHT_EASE_UNIT[profile].out(u); // [0.5..1]
      }

      return lerp(startY, endY, shaped01);
    };

    for (let n = 0; n < e; n++){
      const tCurve = e > 0 ? n / e : 1;
      addSegment(
        CURVE_EASE[profile].in(0, curve, tCurve),
        computeY((0 + n) / total),
        buildFeatures(segOffset)
      );
      segOffset++;
    }

    for (let n = 0; n < h; n++){
      addSegment(
        curve,
        computeY((e + n) / total),
        buildFeatures(segOffset)
      );
      segOffset++;
    }

    for (let n = 0; n < l; n++){
      const tCurve = l > 0 ? n / l : 1;
      addSegment(
        CURVE_EASE[profile].out(curve, 0, tCurve),
        computeY((e + h + n) / total),
        buildFeatures(segOffset)
      );
      segOffset++;
    }
  }

  async function buildTrackFromCSV(url){
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error('CSV load failed: ' + res.status);
    const text = await res.text();

    const toInt = (v, d=0) => {
      if (v === '' || v == null) return d;
      const n = parseInt(v, 10);
      return Number.isNaN(n) ? d : n;
    };
    const toFloat = (v, d=0) => {
      if (v === '' || v == null) return d;
      const n = parseFloat(v);
      return Number.isNaN(n) ? d : n;
    };
    const boolTrueTokens = ['1','true','yes','y','on'];
    const boolFalseTokens = ['0','false','no','n','off'];
    const boolWordTokens = ['true','yes','y','on','false','no','n','off'];
    const toBool = (v, d=true) => {
      if (v === '' || v == null) return d;
      const norm = v.toLowerCase();
      if (boolTrueTokens.includes(norm)) return true;
      if (boolFalseTokens.includes(norm)) return false;
      return d;
    };
    const isBoolToken = (v) => {
      if (v === '' || v == null) return false;
      const norm = v.toLowerCase();
      return boolWordTokens.includes(norm);
    };

    const typeAliases = {
      road: 'road', r: 'road',
      straight: 'straight', flat: 'straight', s: 'straight',
      curve: 'curve', c: 'curve', turn: 'curve',
      hill: 'smoothHill', h: 'smoothHill', rise: 'smoothHill',
      smoothhill: 'smoothHill', smooth: 'smoothHill',
      sharphill: 'sharpHill', sharp: 'sharpHill'
    };

    const lines = text.split(/\r?\n/);
    segments.length = 0;
    boostZoneIdCounter = 0;

    for (const raw of lines){
      const line = raw.trim();
      if (!line || line.startsWith('#') || line.startsWith('//')) continue;

      const cells = line.split(',').map(s => (s ?? '').trim());
      const typeRaw = cells[0];
      const enter = cells[1];
      const hold = cells[2];
      const leave = cells[3];
      let curveRaw;
      let dyRaw;
      let railRaw;
      let boostStartRaw;
      let boostEndRaw;
      let repeatsRaw;
      let repeatsIdx = null;

      if (isBoolToken(cells[7])) {
        // Legacy format with hillMult column present
        curveRaw = cells[5];
        dyRaw = cells[6];
        railRaw = cells[7];
        boostStartRaw = cells[8];
        boostEndRaw = cells[9];
        repeatsRaw = cells[10];
        repeatsIdx = 10;
      } else {
        curveRaw = cells[4];
        dyRaw = cells[5];
        railRaw = cells[6];
        boostStartRaw = cells[7];
        boostEndRaw = cells[8];
        repeatsRaw = cells[9];
        repeatsIdx = 9;
      }

      if (repeatsRaw === undefined){
        // Legacy format: type, enter, hold, leave, curve, dy, repeats[, comment]
        curveRaw = cells[4];
        dyRaw = cells[5];
        repeatsRaw = cells[6];
        railRaw = '';
        boostStartRaw = '';
        boostEndRaw = '';
        repeatsIdx = 6;
      }

      const typeNorm = (typeRaw || 'road').toLowerCase();
      const type = typeAliases[typeNorm] || 'road';
      const e = Math.max(0, toInt(enter, 0));
      const h = Math.max(0, toInt(hold, 0));
      const l = Math.max(0, toInt(leave, 0));
      let c = toFloat(curveRaw, 0);
      let y = toFloat(dyRaw, 0);
      const rail = toBool(railRaw, true);
      const boostStart = (boostStartRaw === '' || boostStartRaw == null) ? null : toInt(boostStartRaw, null);
      const boostEnd = (boostEndRaw === '' || boostEndRaw == null) ? null : toInt(boostEndRaw, null);
      const extrasAfter = (repeatsIdx != null) ? cells.slice(repeatsIdx + 1) : [];
      const boostTypeRaw = extrasAfter.length > 0 ? extrasAfter[0] : '';
      const boostLaneStartRaw = extrasAfter.length > 1 ? extrasAfter[1] : '';
      const boostLaneEndRaw = extrasAfter.length > 2 ? extrasAfter[2] : '';
      const boostVisibleRaw = extrasAfter.length > 3 ? extrasAfter[3] : '';
      const reps = Math.max(1, toInt(repeatsRaw, 1));

      let elevationProfile = 'smooth';

      if (type === 'straight'){
        elevationProfile = 'linear';
      }
      else if (type === 'curve' && (dyRaw === '' || dyRaw == null)) {
        y = 0;
      }
      else if (type === 'smoothHill'){
        elevationProfile = 'smooth';
      }
      else if (type === 'sharpHill'){
        elevationProfile = 'sharp';
      }

      const features = { rail };
      if (boostStart != null && boostEnd != null && boostEnd >= boostStart) {
        const start = Math.max(0, boostStart|0);
        const end = Math.max(start, boostEnd|0);
        if (!(start === 0 && end === 0)) {
          const parsedType = parseBoostZoneType(boostTypeRaw) || BOOST_ZONE_TYPES.JUMP;
          const laneStart = parseBoostLaneValue(boostLaneStartRaw);
          const laneEnd = parseBoostLaneValue(boostLaneEndRaw);
          const fallbackStart = clampBoostLane(-2);
          const fallbackEnd = clampBoostLane(2);
          const laneA = clampBoostLane((laneStart != null) ? laneStart : fallbackStart);
          const laneB = clampBoostLane((laneEnd != null) ? laneEnd : fallbackEnd);
          const nStart = Math.min(laneA, laneB);
          const nEnd = Math.max(laneA, laneB);
          const zoneVisible = toBool(boostVisibleRaw, true);
          const zone = {
            id: `csv-${boostZoneIdCounter++}`,
            startOffset: start,
            endOffset: end,
            type: parsedType,
            nStart,
            nEnd,
            visible: zoneVisible,
          };
          features.boostZones = [zone];
          features.boostRange = [start, end];
        }
      }

      for (let i=0;i<reps;i++){
        addRoad(e, h, l, c, y, elevationProfile, features);
      }
    }

    if (segments.length === 0) throw new Error('CSV produced no segments');
    trackLength = segments.length * segmentLength;
  }

  async function buildCliffsFromCSV_Lite(url){
    if (!segments.length) return;
    resetCliffSeries();

    let text='';
    try {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      text = await res.text();
    } catch (e) {
      console.warn('Cliff CSV not found, using flat cliffs:', e);
      CLIFF_READY = true;
      return;
    }

    const toInt =(v,d=0)=> (v===''||v==null)?d: (Number.isNaN(parseInt(v,10))?d:parseInt(v,10));
    const toNum =(v,d=0)=> (v===''||v==null)?d: (Number.isNaN(parseFloat(v))?d:parseFloat(v));
    const normSide = (s)=> (s||'').trim().toUpperCase();

    const N = segments.length;
    const head = { L:0, R:0 };
    const state = {
      L: { Ax:0, Ay:0, Bx:0, By:0 },
      R: { Ax:0, Ay:0, Bx:0, By:0 },
    };

    const lines = text.split(/\r?\n/);
    for (const raw of lines){
      const line = raw.trim();
      if (!line || line.startsWith('#') || line.startsWith('//')) continue;

      const c = line.split(',').map(s => (s??'').trim());
      const sideTok = normSide(c[0]||'B');
      const sides = (sideTok==='L'||sideTok==='R') ? [sideTok] : (sideTok==='B' ? ['L','R'] : ['L','R']);

      const len = Math.max(1, toInt(c[1], 1));
      const aEase = getEase01(c[2]||'smooth:io');
      const aDx   = toNum(c[3], 0), aDy = toNum(c[4], 0);
      const bEase = getEase01(c[5]||'smooth:io');
      const bDx   = toNum(c[6], 0), bDy = toNum(c[7], 0);
      const mode  = (c[8]||'rel').toLowerCase()==='abs' ? 'abs' : 'rel';
      const reps  = Math.max(1, toInt(c[9], 1));

      for (let r=0; r<reps; r++){
        for (const S of sides){
          const st = state[S];
          const start = head[S];
          const from = { Ax: st.Ax, Ay: st.Ay, Bx: st.Bx, By: st.By };
          const target = (mode==='abs') ?
            { Ax:aDx, Ay:aDy, Bx:bDx, By:bDy } :
            { Ax: st.Ax + aDx, Ay: st.Ay + aDy, Bx: st.Bx + bDx, By: st.By + bDy };

          const steps = Math.max(1, len);
          const denom = steps <= 1 ? 1 : (steps - 1);

          for (let i=0; i<steps; i++){
            const idx = (start + i) % N;
            const t = (steps <= 1) ? 1 : (i / denom);
            const sA = aEase(t), sB = bEase(t);

            const Ax = lerp(from.Ax, target.Ax, sA);
            const Ay = lerp(from.Ay, target.Ay, sA);
            const Bx = lerp(from.Bx, target.Bx, sB);
            const By = lerp(from.By, target.By, sB);

            if (S==='L'){
              CLIFF_SERIES.leftA.dx[idx]=Ax;  CLIFF_SERIES.leftA.dy[idx]=Ay;
              CLIFF_SERIES.leftB.dx[idx]=Bx;  CLIFF_SERIES.leftB.dy[idx]=By;
            } else {
              CLIFF_SERIES.rightA.dx[idx]=Ax; CLIFF_SERIES.rightA.dy[idx]=Ay;
              CLIFF_SERIES.rightB.dx[idx]=Bx; CLIFF_SERIES.rightB.dy[idx]=By;
            }
          }

          head[S] = start + steps;
          st.Ax = target.Ax; st.Ay = target.Ay;
          st.Bx = target.Bx; st.By = target.By;
        }
      }
    }

    const fillRemainder = (S) => {
      const st = state[S];
      const start = head[S];
      if (start >= N) return;
      for (let i=start; i<N; i++){
        if (S==='L'){
          CLIFF_SERIES.leftA.dx[i]=st.Ax;  CLIFF_SERIES.leftA.dy[i]=st.Ay;
          CLIFF_SERIES.leftB.dx[i]=st.Bx;  CLIFF_SERIES.leftB.dy[i]=st.By;
        } else {
          CLIFF_SERIES.rightA.dx[i]=st.Ax; CLIFF_SERIES.rightA.dy[i]=st.Ay;
          CLIFF_SERIES.rightB.dx[i]=st.Bx; CLIFF_SERIES.rightB.dy[i]=st.By;
        }
      }
    };

    fillRemainder('L');
    fillRemainder('R');

    CLIFF_READY = true;
  }

  function enforceCliffWrap(copySpan = 1){
    if (!CLIFF_READY || !segments.length) return;
    const n = segments.length;
    const copyAt = (dst, src, side) => {
      side.dx[dst] = side.dx[src];
      side.dy[dst] = side.dy[src];
    };
    for (let k = 0; k < copySpan; k++){
      const dst = k;           // beginning
      const src = (n - 1 - k + n) % n; // end
      copyAt(dst, src, CLIFF_SERIES.leftA);  copyAt(dst, src, CLIFF_SERIES.leftB);
      copyAt(dst, src, CLIFF_SERIES.rightA); copyAt(dst, src, CLIFF_SERIES.rightB);
    }
  }

  // ---------- Texture tiling zones ----------
  let roadTexZones = [], railTexZones = [], cliffTexZones = [];
  function pushZone(stack, start, end, tile=1){
    if (end < start) [start, end] = [end, start];
    stack.push({ start, end, tile: Math.max(1, tile|0) });
  }
  function findZone(stack, segIndex){
    for (let i=stack.length-1; i>=0; i--){
      const z = stack[i];
      if (segIndex>=z.start && segIndex<=z.end) return z;
    }
    return null;
  }
  function vSpanForSeg(zones, segIndex){
    const z = findZone(zones, segIndex);
    if (!z) return [0,1];
    const perSeg = 1 / Math.max(1, z.tile);
    const segPos = (segIndex - z.start);
    const v0 = (segPos % z.tile) * perSeg;
    const v1 = v0 + perSeg;
    return [v0, v1];
  }

  // ---------- Overlap (shared) ----------
  const OVERLAP = { x: 0.75, y: 0.75 }; // screen-space pixels to overdraw

  function padQuad(q, { padLeft=0, padRight=0, padTop=0, padBottom=0 } = {}) {
    // Returns a new quad with edges expanded in screen space. Positive padding values
    // enlarge the quad outward along each axis regardless of vertex winding/order.
    const xs = [q.x1, q.x2, q.x3, q.x4];
    const ys = [q.y1, q.y2, q.y3, q.y4];
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);

    const adjustX = (x) => {
      const dMin = Math.abs(x - minX);
      const dMax = Math.abs(x - maxX);
      return x + (dMin <= dMax ? -padLeft : padRight);
    };
    const adjustY = (y) => {
      const dMin = Math.abs(y - minY);
      const dMax = Math.abs(y - maxY);
      return y + (dMin <= dMax ? -padTop : padBottom);
    };

    return {
      x1: adjustX(q.x1), y1: adjustY(q.y1),
      x2: adjustX(q.x2), y2: adjustY(q.y2),
      x3: adjustX(q.x3), y3: adjustY(q.y3),
      x4: adjustX(q.x4), y4: adjustY(q.y4),
    };
  }

  // ---------- Helpers / math ----------
  const pctRem=(n,total)=>(n%total)/total;
  const lerp=(a,b,t)=>a+(b-a)*t;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const overlap  = (ax, aw, bx, bw, scale=1.0) => Math.abs(ax - bx) < (aw + bw) * scale;

  const segmentAtS=s=>segments[Math.floor(( (s%trackLength+trackLength)%trackLength )/segmentLength) % segments.length];
  const segmentAtIndex = (idx) => {
    if (!segments.length) return null;
    const count = segments.length;
    const wrapped = ((idx % count) + count) % count;
    return segments[wrapped];
  };

  function boostZonesOnSegment(seg) {
    if (!seg || !seg.features) return [];
    const zones = seg.features.boostZones;
    return Array.isArray(zones) ? zones : [];
  }
  function playerWithinBoostZone(zone, nNorm) {
    if (!zone) return false;
    const fallbackStart = clampBoostLane(-2);
    const fallbackEnd = clampBoostLane(2);
    const start = (zone.nStart != null) ? zone.nStart : fallbackStart;
    const end = (zone.nEnd != null) ? zone.nEnd : fallbackEnd;
    const min = Math.min(start, end);
    const max = Math.max(start, end);
    return nNorm >= min && nNorm <= max;
  }
  function boostZonesForPlayer(seg, nNorm) {
    const zones = boostZonesOnSegment(seg);
    if (!zones.length) return [];
    return zones.filter(zone => playerWithinBoostZone(zone, nNorm));
  }

  function elevationAt(s){
    if(trackLength<=0) return 0;
    let ss=s%trackLength; if(ss<0) ss+=trackLength;
    const i=Math.floor(ss/segmentLength), seg=segments[i%segments.length], t=(ss-seg.p1.world.z)/segmentLength;
    return lerp(seg.p1.world.y, seg.p2.world.y, t);
  }
  function groundProfileAt(s){
    const y=elevationAt(s), h=Math.max(5.0, segmentLength*0.1), y1=elevationAt(s-h), y2=elevationAt(s+h);
    const dy=(y2-y1)/(2*h), d2y=(y2-2*y+y1)/(h*h);
    return { y, dy, d2y };
  }
  const computeCurvature=(dy,d2y)=> d2y/Math.pow(1+dy*dy,1.5);
  const tangentNormalFromSlope=(dy)=>{ const inv=1/Math.sqrt(1+dy*dy); return { tx:inv, ty:dy*inv, nx:-dy*inv, ny:inv }; };
  const wrapDistance = (v, dv, max) => { v += dv; while (v >= max) v -= max; while (v < 0) v += max; return v; };

  function nearestSegmentCenter(s) {
    const i = Math.round(s / segmentLength);
    return i * segmentLength + segmentLength * 0.5;
  }

  // ---------- Cliff params (per segment) ----------
  function cliffParamsAt(segIndex, t=0){
    const n = segments.length;
    if (n === 0) {
      return {
        leftA:  { dx:0, dy:0 },
        leftB:  { dx:0, dy:0 },
        rightA: { dx:0, dy:0 },
        rightB: { dx:0, dy:0 },
      };
    }

    const u = clamp01(t);
    const i0 = ((segIndex % n) + n) % n;
    const i1 = (i0 + 1) % n;

    const mix = (arr, a, b) => lerp(arr[a], arr[b], u);

    if (!CLIFF_READY) {
      return {
        leftA:  { dx:0, dy:0 },
        leftB:  { dx:0, dy:0 },
        rightA: { dx:0, dy:0 },
        rightB: { dx:0, dy:0 },
      };
    }

    return {
      leftA:  { dx: mix(CLIFF_SERIES.leftA.dx,  i0, i1), dy: mix(CLIFF_SERIES.leftA.dy,  i0, i1) },
      leftB:  { dx: mix(CLIFF_SERIES.leftB.dx,  i0, i1), dy: mix(CLIFF_SERIES.leftB.dy,  i0, i1) },
      rightA: { dx: mix(CLIFF_SERIES.rightA.dx, i0, i1), dy: mix(CLIFF_SERIES.rightA.dy, i0, i1) },
      rightB: { dx: mix(CLIFF_SERIES.rightB.dx, i0, i1), dy: mix(CLIFF_SERIES.rightB.dy, i0, i1) },
    };
  }

  // ---------- World<->screen ----------
  function projectPoint(p, camX, camY, camS){
    p.camera = p.camera||{}; p.screen = p.screen||{};
    p.camera.x = (p.world.x||0) - camX;
    p.camera.y = (p.world.y||0) - camY;
    p.camera.z = (p.world.z||0) - camS;
    p.screen.scale = 1/Math.tan((TUNE_TRACK.fov/2)*Math.PI/180) / p.camera.z;
    p.screen.x = (HALF_VIEW + p.screen.scale*p.camera.x*HALF_VIEW)|0;
    p.screen.y = ((H/2) - p.screen.scale*p.camera.y*(H/2))|0;
    const rw = roadWidthAt(p.world.z||0);
    p.screen.w = (p.screen.scale*rw*HALF_VIEW)|0;
  }

  // ---------- Cliff quad builders ----------
  function makeCliffLeftQuads(x1,y1,w1, x2,y2,w2, yA1,yA2, yB1,yB2, dxA0, dxA1, dxB0, dxB1, u0,u1, rw1, rw2){
    const k1 = w1 / Math.max(1e-6, rw1), k2 = w2 / Math.max(1e-6, rw2);
    const x1_inner = x1 - w1, y1_inner = y1;
    const x2_inner = x2 - w2, y2_inner = y2;
    const x1_A = x1_inner - dxA0 * k1;
    const x2_A = x2_inner - dxA1 * k2;
    const x1_B = x1_A     - dxB0 * k1;
    const x2_B = x2_A     - dxB1 * k2;
    const quadA = { x1:x1_A, y1:yA1, x2:x1_inner, y2:y1_inner, x3:x2_inner, y3:y2_inner, x4:x2_A, y4:yA2 };
    const uvA   = { u1:u0, v1:0, u2:u0, v2:0, u3:u1, v3:1, u4:u1, v4:1 };
    const quadB = { x1:x1_B, y1:yB1, x2:x1_A, y2:yA1, x3:x2_A, y3:yA2, x4:x2_B, y4:yB2 };
    const uvB   = { u1:u0, v1:0, u2:u0, v2:0, u3:u1, v3:1, u4:u1, v4:1 };
    return {quadA, uvA, quadB, uvB, x1_inner, x2_inner, x1_A, x2_A, x1_B, x2_B};
  }
  function makeCliffRightQuads(x1,y1,w1, x2,y2,w2, yA1,yA2, yB1,yB2, dxA0, dxA1, dxB0, dxB1, u0,u1, rw1, rw2){
    const k1 = w1 / Math.max(1e-6, rw1), k2 = w2 / Math.max(1e-6, rw2);
    const x1_inner = x1 + w1, y1_inner = y1;
    const x2_inner = x2 + w2, y2_inner = y2;
    const x1_A = x1_inner + dxA0 * k1;
    const x2_A = x2_inner + dxA1 * k2;
    const x1_B = x1_A     + dxB0 * k1;
    const x2_B = x2_A     + dxB1 * k2;
    const quadA = { x1:x1_inner, y1:y1_inner, x2:x1_A, y2:yA1, x3:x2_A, y3:yA2, x4:x2_inner, y4:y2_inner };
    const uvA   = { u1:u0, v1:0, u2:u0, v2:0, u3:u1, v3:1, u4:u1, v4:1 };
    const quadB = { x1:x1_A, y1:yA1, x2:x1_B, y2:yB1, x3:x2_B, y3:yB2, x4:x2_A, y4:yA2 };
    const uvB   = { u1:u0, v1:0, u2:u0, v2:0, u3:u1, v3:1, u4:u1, v4:1 };
    return {quadA, uvA, quadB, uvB, x1_inner, x2_inner, x1_A, x2_A, x1_B, x2_B};
  }

  // ---------- Fog & sprites helpers ----------
  const fogNear = () => FOG.nearSegs * segmentLength;
  const fogFar  = () => FOG.farSegs  * segmentLength;
  function fogFactorFromZ(z){
    if (!FOG.enabled) return 0;
    const n = fogNear(), f = fogFar();
    if (f <= n) return z >= f ? 1 : 0;
    return clamp((z - n) / (f - n), 0, 1);
  }
  function spriteFarScaleFromZ(z){
    if (!FOG.enabled) return 1;
    const f = fogFactorFromZ(z);
    return 1 - (1 - SPRITE_FAR.shrinkTo) * Math.pow(f, SPRITE_FAR.power);
  }

  // ---------- Parallax ----------
  function drawParallaxLayer(tex, cfg){
    if (!tex) return;
    const uOffset = playerN * cfg.parallaxX;
    const quad = { x1:0, y1:0, x2:W, y2:0, x3:W, y3:H, x4:0, y4:H };
    const uv = {u1: uOffset, v1: 0, u2: uOffset+cfg.uvSpanX, v2: 0, u3: uOffset+cfg.uvSpanX, v3: cfg.uvSpanY, u4: uOffset, v4: cfg.uvSpanY};
    glr.drawQuadTextured(tex, quad, uv, [1,1,1,1], [0,0,0,0]);
  }
  function renderHorizon(){
    for (const layer of PARALLAX_LAYERS){
      drawParallaxLayer(textures[layer.key], layer);
    }
  }

  // ---------- Road strip ----------
  function drawRoadStrip(x1,y1,w1, x2,y2,w2, v0, v1, fogRoad, tex){
    if (!tex) tex = glr.whiteTex;

    // --- rows: screen-space along Y (prevents trapezoid stretch)
    const dy   = Math.abs(y1 - y2);
    const rows = Math.max(1, Math.min(ROW_MAX, Math.ceil(dy / ROW_PX_TARGET)));

    // --- cols: across width; adapt by average on-screen width
    const avgW = 0.5 * (w1 + w2);
    let cols = Math.max(1, Math.round(avgW / COL_PX_TARGET));
    cols = clamp(cols, ROAD_COLS_FAR, ROAD_COLS_NEAR);

    const fNear = fogRoad[0], fFar = fogRoad[2];

    for (let i = 0; i < rows; i++){
      const t0 = i / rows, t1 = (i + 1) / rows;

      const xa = lerp(x1, x2, t0), ya = lerp(y1, y2, t0), wa = lerp(w1, w2, t0);
      const xb = lerp(x1, x2, t1), yb = lerp(y1, y2, t1), wb = lerp(w1, w2, t1);

      const vv0 = lerp(v0, v1, t0), vv1 = lerp(v0, v1, t1);
      const fA  = lerp(fNear, fFar, t0), fB = lerp(fNear, fFar, t1);

      for (let j = 0; j < cols; j++){
        const u0 = j / cols, u1 = (j + 1) / cols;
        const k0 = -1 + 2 * (j / cols);
        const k1 = -1 + 2 * ((j + 1) / cols);

        const quadBase = {
          x1: xa + wa * k0, y1: ya,
          x2: xa + wa * k1, y2: ya,
          x3: xb + wb * k1, y3: yb,
          x4: xb + wb * k0, y4: yb
        };

        // Row overlap (tuck up/down) and column overlap (tuck left/right)
        const colPadL = (j === 0)        ? OVERLAP.x : OVERLAP.x * 0.5;
        const colPadR = (j === cols - 1) ? OVERLAP.x : OVERLAP.x * 0.5;
        const quad = padQuad(quadBase, {
          padLeft:  colPadL,
          padRight: colPadR,
          padTop:   OVERLAP.y,
          padBottom:OVERLAP.y
        });
        const uv = { u1:u0, v1:vv0, u2:u1, v2:vv0, u3:u1, v3:vv1, u4:u0, v4:vv1 };
        glr.drawQuadTextured(tex, quad, uv, DEFAULT_COLORS.road, [fA,fA,fB,fB]);
      }
    }
  }

  function drawBoostZonesOnStrip(zones, xNear, yNear, xFar, yFar, wNear, wFar, fogRoad){
    if (!zones || !zones.length) return;
    for (const zone of zones){
      if (!zone || zone.visible === false) continue;
      const fallbackStart = clampBoostLane(-2);
      const fallbackEnd = clampBoostLane(2);
      const startN = (zone.nStart != null) ? zone.nStart : fallbackStart;
      const endN = (zone.nEnd != null) ? zone.nEnd : fallbackEnd;
      const laneMin = Math.min(startN, endN);
      const laneMax = Math.max(startN, endN);
      const laneMinClamped = clampBoostLane(laneMin);
      const laneMaxClamped = clampBoostLane(laneMax);

      const nearMin = xNear + wNear * laneToCenterOffset(laneMinClamped, fallbackStart);
      const nearMax = xNear + wNear * laneToCenterOffset(laneMaxClamped, fallbackEnd);
      const farMin  = xFar  + wFar  * laneToCenterOffset(laneMinClamped, fallbackStart);
      const farMax  = xFar  + wFar  * laneToCenterOffset(laneMaxClamped, fallbackEnd);

      const quad = {
        x1: nearMin, y1: yNear,
        x2: nearMax, y2: yNear,
        x3: farMax,  y3: yFar,
        x4: farMin,  y4: yFar,
      };
      const padded = padQuad(quad, {
        padLeft:   OVERLAP.x,
        padRight:  OVERLAP.x,
        padTop:    OVERLAP.y,
        padBottom: OVERLAP.y,
      });
      const colors = BOOST_ZONE_COLORS[zone.type] || BOOST_ZONE_FALLBACK_COLOR;
      const solid = Array.isArray(colors.solid) ? colors.solid : BOOST_ZONE_FALLBACK_COLOR.solid;
      glr.drawQuadSolid(padded, solid, fogRoad);
    }
  }

  // ---------- Billboard helpers ----------
  function drawBillboard(xCenter, baseY, wPx, hPx, fogZ, tint=[1,1,1,1], texture=null){
    const x1 = xCenter - wPx/2, x2 = xCenter + wPx/2;
    const y1 = baseY - hPx, y2 = baseY;
    const uv = {u1:0,v1:0,u2:1,v2:0,u3:1,v3:1,u4:0,v4:1};
    const fog = [fogFactorFromZ(fogZ), fogFactorFromZ(fogZ), fogFactorFromZ(fogZ), fogFactorFromZ(fogZ)];
    const quad = {x1:x1, y1:y1, x2:x2, y2:y1, x3:x2, y3:y2, x4:x1, y4:y2};
    if (texture) glr.drawQuadTextured(texture, quad, uv, tint, fog);
    else         glr.drawQuadSolid(quad, tint, fog);
    const shadowH = Math.max(2, hPx*0.06);
    const shQuad = {x1:x1, y1:y2-shadowH, x2:x2, y2:y2-shadowH, x3:x2, y3:y2, x4:x1, y4:y2};
    glr.drawQuadSolid(shQuad, [0,0,0,0.25], fog);
  }
  function makeRotatedQuad(cx, cy, w, h, rad){
    const c = Math.cos(rad), s = Math.sin(rad);
    const hw = w * 0.5, hh = h * 0.5;
    const x1=-hw, y1=-hh, x2= hw, y2=-hh, x3= hw, y3= hh, x4=-hw, y4= hh;
    const rx1 = c*x1 - s*y1 + cx, ry1 = s*x1 + c*y1 + cy;
    const rx2 = c*x2 - s*y2 + cx, ry2 = s*x2 + c*y2 + cy;
    const rx3 = c*x3 - s*y3 + cx, ry3 = s*x3 + c*y3 + cy;
    const rx4 = c*x4 - s*y4 + cx, ry4 = s*x4 + c*y4 + cy;
    return { x1:rx1, y1:ry1, x2:rx2, y2:ry2, x3:rx3, y3:ry3, x4:rx4, y4:ry4 };
  }

  // ---------- Physics / player ----------
  const phys={ s:0,y:0,vx:0,vy:0,vtan:0, grounded:true, t:0, nextHopTime:0, boostFlashTimer:0 };
  let playerN=0; // lateral normalized [-2..2]
  let fieldOfView  = TUNE_TRACK.fov;
  let cameraDepth  = 1/Math.tan((fieldOfView/2)*Math.PI/180);
  let nearZ        = 1 / cameraDepth;
  let playerZ      = TUNE_TRACK.cameraHeight*cameraDepth;
  let camYSmooth=0;

  let hopHeld=false;
  let driftState='idle';
  let driftDirSnapshot=0;
  let driftCharge=0;
  let allowedBoost=false;
  let boostTimer=0;
  let activeDriveZoneId=null;

  const input = { left:false,right:false,up:false,down:false, hop:false };
  addEventListener('keydown',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=true;
    if(e.code==='ArrowRight'||e.code==='KeyD') input.right=true;
    if(e.code==='ArrowUp'||e.code==='KeyW') input.up=true;
    if(e.code==='ArrowDown'||e.code==='KeyS') input.down=true;
    if(e.code==='Space'){ if(!hopHeld){ input.hop=true; } hopHeld=true; }
    if(e.code==='KeyR') queueReset();
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=false;
    if(e.code==='ArrowRight'||e.code==='KeyD') input.right=false;
    if(e.code==='ArrowUp'||e.code==='KeyW') input.up=false;
    if(e.code==='ArrowDown'||e.code==='KeyS') input.down=false;
    if(e.code==='Space'){
      hopHeld=false;
      if (allowedBoost) boostTimer = DRIFT.boostTime;
      driftState='idle'; driftDirSnapshot=0; driftCharge=0; allowedBoost=false;
    }
  });

  function doHop(){
    if (!phys.grounded || phys.t < phys.nextHopTime) return false;
    const segNow = segmentAtS(phys.s);
    const zonesHere = boostZonesForPlayer(segNow, playerN);
    const jumpZone = zonesHere.find(zone => zone.type === BOOST_ZONE_TYPES.JUMP);
    const { dy } = groundProfileAt(phys.s);
    const { tx, ty, nx, ny } = tangentNormalFromSlope(dy);
    const baseVx = phys.vtan * tx, baseVy = phys.vtan * ty;
    let newVx = baseVx + nx * TUNE_PLAYER.hopImpulse;
    let newVy = baseVy + ny * TUNE_PLAYER.hopImpulse;
    phys.vx=newVx; phys.vy=newVy;
    phys.grounded=false;
    phys.nextHopTime=phys.t+TUNE_PLAYER.hopCooldown;
    if (jumpZone) {
      boostTimer = Math.max(boostTimer, DRIFT.boostTime);
      phys.boostFlashTimer = Math.max(phys.boostFlashTimer, 0.3);
    }
    return true;
  }

  const PLAYER_PAD = 0.015;
  function playerHalfWN() { return SPRITE_META.PLAYER.wN * getKindScale('PLAYER') * 0.5; }

  function playerLateralLimit(segIndex){
    const halfW = playerHalfWN();
    const base  = 2 - halfW - PLAYER_PAD;
    const seg = segmentAtIndex(segIndex);
    if (seg && seg.features && seg.features.rail) {
      const railInner = TUNE_TRACK.railInset - halfW - PLAYER_PAD;
      return Math.min(base, railInner);
    }
    return base;
  }

  function updatePhysics(dt){
    if(input.hop){ doHop(); input.hop=false; }

    // steering
    const steerAxis = (input.left&&input.right)?0:(input.left?-1:(input.right?+1:0));
    const boosting = (boostTimer > 0);
    if (boosting) boostTimer = Math.max(0, boostTimer - dt);
    const speed01 = clamp(Math.abs(phys.vtan)/TUNE_PLAYER.maxSpeed, 0, 1);
    let steerDx = dt * TUNE_PLAYER.steerBase * speed01;
    if (boosting) steerDx *= DRIFT.boostSteerScale;

    if (driftState === 'drifting') {
      let k = DRIFT.boostLockBase;
      if (steerAxis === driftDirSnapshot) k = DRIFT.boostLockWith;
      else if (steerAxis === -driftDirSnapshot) k = DRIFT.boostLockAgainst;
      playerN += steerDx * k * driftDirSnapshot;
    } else {
      if (steerAxis !== 0) playerN += steerDx * steerAxis;
    }

    // centrifugal bias (curve=0 on straight, but keep code)
    const segAhead = segmentAtS(phys.s + playerZ);
    playerN -= steerDx * speed01 * segAhead.curve * TUNE_PLAYER.leanCentrifugal;

    applyCliffPushForce(steerDx);
    playerN = clamp(playerN, -2, 2);

    let segNow = segmentAtS(phys.s);
    const segFeatures = segNow ? segNow.features : null;
    const zonesHere = boostZonesForPlayer(segNow, playerN);
    const hasZonesHere = zonesHere.length > 0;
    const driveZoneHere = zonesHere.find(zone => zone.type === BOOST_ZONE_TYPES.DRIVE) || null;
    const zoneMultBase = hasZonesHere
      ? ((segFeatures && segFeatures.boostMultiplier != null) ? segFeatures.boostMultiplier : TUNE_PLAYER.crestBoostMultiplier)
      : 1;

    const prevGrounded = phys.grounded;
    if (phys.grounded) {
      const { dy } = groundProfileAt(phys.s);
      const { tx, ty } = tangentNormalFromSlope(dy);
      let a=0;
      if(input.up) a+=TUNE_PLAYER.accel;
      if(input.down) a-=TUNE_PLAYER.brake;
      a += -TUNE_PLAYER.gravity*ty;
      a += -TUNE_PLAYER.rollFriction*phys.vtan;
      phys.vtan = clamp(phys.vtan + a*dt, -TUNE_PLAYER.maxSpeed, TUNE_PLAYER.maxSpeed);

      if (driveZoneHere) {
        if (activeDriveZoneId !== driveZoneHere.id) {
          boostTimer = Math.max(boostTimer, DRIFT.boostTime);
          activeDriveZoneId = driveZoneHere.id;
        }
      } else {
        activeDriveZoneId = null;
      }

      const zoneMult = zoneMultBase;
      const travelBase = boosting ? phys.vtan * DRIFT.boostMult : phys.vtan;
      const travelV = travelBase * zoneMult;
      phys.s += travelV * tx * dt;
      phys.y  = groundProfileAt(phys.s).y;

      const { dy: ndy, d2y } = groundProfileAt(phys.s);
      const kap = computeCurvature(ndy, d2y);
      if (kap < 0) {
        const need = phys.vtan * phys.vtan * -kap;
        const support = TUNE_PLAYER.gravity * tangentNormalFromSlope(ndy).ny;
        if (need > support) {
          phys.grounded = false;
          phys.vx = phys.vtan * tangentNormalFromSlope(ndy).tx;
          phys.vy = phys.vtan * tangentNormalFromSlope(ndy).ty;
        }
      }
    } else {
      // airborne
      phys.vy -= TUNE_PLAYER.gravity * dt;
      if (TUNE_PLAYER.airDrag) {
        phys.vx -= TUNE_PLAYER.airDrag * phys.vx * dt;
        phys.vy -= TUNE_PLAYER.airDrag * phys.vy * dt;
      }
      phys.s  += phys.vx * dt;
      phys.y  += phys.vy * dt;

      activeDriveZoneId = null;

      // ground re-contact
      const gy = elevationAt(phys.s);
      const { dy } = groundProfileAt(phys.s);
      if (phys.y <= gy && phys.vy <= phys.vx * dy) {
        const { tx, ty } = tangentNormalFromSlope(dy);
        const vtanNew = phys.vx * tx + phys.vy * ty;
        phys.vtan = clamp(vtanNew, -TUNE_PLAYER.maxSpeed, TUNE_PLAYER.maxSpeed);
        phys.y = gy;
        phys.grounded = true;
      }
    }

    // hop/boost state changes on landing
    if (!prevGrounded && phys.grounded) {
      const landingSeg = segmentAtS(phys.s);
      const landingZones = boostZonesForPlayer(landingSeg, playerN);
      const landingJumpZone = landingZones.find(zone => zone.type === BOOST_ZONE_TYPES.JUMP);
      if (landingJumpZone) {
        boostTimer = Math.max(boostTimer, DRIFT.boostTime);
        phys.boostFlashTimer = Math.max(phys.boostFlashTimer, 0.3);
      }
      const steerAxis2 = (input.left&&input.right)?0:(input.left?-1:(input.right?+1:0));
      if (hopHeld) {
        const dir = (steerAxis2===0) ? 0 : steerAxis2;
        if (dir !== 0) {
          driftState = 'drifting';
          driftDirSnapshot = dir;
          driftCharge = 0;
          allowedBoost = false;
        } else {
          driftState = 'idle'; driftDirSnapshot=0; driftCharge=0; allowedBoost=false;
        }
      } else {
        driftState = 'idle'; driftDirSnapshot=0; driftCharge=0; allowedBoost=false;
      }
    }

    if (driftState === 'drifting') {
      if (hopHeld) {
        if (!allowedBoost) {
          driftCharge += dt;
          if (driftCharge >= DRIFT.boostChargeMin) { driftCharge = DRIFT.boostChargeMin; allowedBoost = true; }
        }
      } else {
        driftState='idle'; driftDirSnapshot=0; driftCharge=0; allowedBoost=false;
      }
    }

    phys.t += dt;

    // wrap along track
    phys.s = (phys.s % trackLength + trackLength) % trackLength;

    // camera Y smoothing
    const aY = 1 - Math.exp(-dt / TUNE_TRACK.camYTau);
    let targetCamY = phys.y + TUNE_TRACK.cameraHeight;
    if (phys.grounded) {
      const floorY = floorElevationAt(phys.s, playerN);
      targetCamY += (floorY - phys.y) * CLIFF_CAMERA_FRACTION;
    }
    camYSmooth += aY * (targetCamY - camYSmooth);

    // lateral velocity for roll
    lateralRate = playerN - prevPlayerN;
    prevPlayerN = playerN;

    // rail bounds and scraping slowdown
    segNow = segmentAtS(phys.s);
    const bound = playerLateralLimit(segNow.index);
    const preClamp = playerN;
    playerN = clamp(playerN, -bound, bound);
    const scraping = Math.abs(preClamp) > bound - 1e-6 || Math.abs(playerN) >= bound - 1e-6;
    if (scraping) {
      const offRoadDecelLimit = TUNE_PLAYER.maxSpeed / 4;
      if (Math.abs(phys.vtan) > offRoadDecelLimit){
        const sign = Math.sign(phys.vtan)||1;
        phys.vtan -= sign * (TUNE_PLAYER.maxSpeed * 0.8) * (1/60);
      }
    }

    resolveCollisions();

    // failsafe
    if (!resetMatte.active) {
      const roadY = elevationAt(phys.s);
      const bodyY = phys.grounded ? floorElevationAt(phys.s, playerN) : phys.y;
      if ((bodyY != null) && ((roadY - bodyY) > FAILSAFE.belowRoadUnits)) {
        queueRespawn(phys.s);
      }
    }
  }

  // ---------- Cliff interaction helpers ----------
  function cliffSurfaceInfoAt(segIndex, nNorm, t = 0){
    const zeroInfo = () => ({
      heightOffset: 0,
      slope: 0,
      section: null,
      slopeA: 0,
      slopeB: 0,
      coverageA: 0,
      coverageB: 0,
    });

    if (!CLIFF_READY || !segments.length) {
      return zeroInfo();
    }

    const absN = Math.abs(nNorm);
    if (absN <= 1) return zeroInfo();

    const params = cliffParamsAt(segIndex, t);
    const left = nNorm < 0;
    const sign = Math.sign(nNorm) || 1;

    const dyA = left ? params.leftA.dy : params.rightA.dy;
    const dyB = left ? params.leftB.dy : params.rightB.dy;
    const dxA = Math.abs(left ? params.leftA.dx : params.rightA.dx);
    const dxB = Math.abs(left ? params.leftB.dx : params.rightB.dx);

    const idxNorm = ((segIndex % segments.length) + segments.length) % segments.length;
    const segData = segments[idxNorm];
    const baseZ = segData ? segData.p1.world.z : segIndex * segmentLength;
    const roadW = roadWidthAt(baseZ + clamp01(t) * segmentLength);
    const beyond = Math.max(0, (absN - 1) * roadW);

    const widthA = Math.max(0, dxA);
    const widthB = Math.max(0, dxB);
    const totalWidth = widthA + widthB;

    const slopeA = (widthA > 1e-6) ? sign * (dyA / widthA) : 0;
    const slopeB = (widthB > 1e-6) ? sign * (dyB / widthB) : 0;

    if (beyond <= 1e-6) {
      return { heightOffset: 0, slope: 0, section: null, slopeA, slopeB, coverageA: 0, coverageB: 0 };
    }

    if (totalWidth <= 1e-6) {
      return { heightOffset: dyA + dyB, slope: 0, section: null, slopeA, slopeB, coverageA: 0, coverageB: 0 };
    }

    const distA = Math.min(beyond, widthA);
    const distB = Math.max(0, Math.min(beyond - widthA, widthB));

    let heightOffset = 0;
    let coverageA = 0;
    let coverageB = 0;
    if (widthA > 1e-6) {
      coverageA = distA / widthA;
      heightOffset += dyA * coverageA;
    }
    if (widthB > 1e-6) {
      coverageB = distB / widthB;
      heightOffset += dyB * coverageB;
    }

    if (beyond >= totalWidth - 1e-6) {
      return { heightOffset: dyA + dyB, slope: 0, section: null, slopeA, slopeB, coverageA: 0, coverageB: 0 };
    }

    if (distB > 1e-6 && widthB > 1e-6) {
      const slope = slopeB;
      return { heightOffset, slope, section: 'B', slopeA, slopeB, coverageA, coverageB };
    }

    if (distA > 1e-6 && widthA > 1e-6) {
      const slope = slopeA;
      return { heightOffset, slope, section: 'A', slopeA, slopeB, coverageA, coverageB };
    }

    return { heightOffset, slope: 0, section: null, slopeA, slopeB, coverageA, coverageB };
  }
  function floorElevationAt(s, nNorm){
    const base = elevationAt(s);
    const seg = segmentAtS(s);
    if (!seg) return base;
    const segT = clamp01((s - seg.p1.world.z) / segmentLength);
    const info = cliffSurfaceInfoAt(seg.index, nNorm, segT);
    return base + info.heightOffset;
  }
  function cliffLateralSlopeAt(segIndex, nNorm, t=0){
    const info = cliffSurfaceInfoAt(segIndex, nNorm, t);
    return info.slope;
  }
  function applyCliffPushForce(step){
    const ax = Math.abs(playerN);
    if (ax <= 1) return;
    const seg = segmentAtS(phys.s);
    const idx = seg ? seg.index : 0;
    const segT = seg ? clamp01((phys.s - seg.p1.world.z) / segmentLength) : 0;
    const slope = cliffLateralSlopeAt(idx, playerN, segT);
    if (Math.abs(slope) <= 1e-6) return;
    const dir = -Math.sign(slope);
    if (dir === 0) return;
    const s = Math.max(0, Math.min(1.5, ax - 1));
    const gain = 1 + CLIFF_PUSH.distanceGain * s;
    let delta = dir * step * TUNE_TRACK.cliffPush * gain;
    delta = Math.max(-CLIFF_PUSH.capPerFrame, Math.min(CLIFF_PUSH.capPerFrame, delta));
    playerN += delta;
  }
  function getAdditiveTiltDeg(){
    if (!cfgTiltAdd.tiltAddEnabled) return 0;
    const seg = segmentAtS(phys.s);
    if (!seg) return 0;
    const segT = clamp01((phys.s - seg.p1.world.z) / segmentLength);
    const halfWidth = playerHalfWN();
    const leftEdge = playerN - halfWidth;
    const rightEdge = playerN + halfWidth;
    const sampleN = (Math.abs(leftEdge) > Math.abs(rightEdge)) ? leftEdge : rightEdge;
    const info = cliffSurfaceInfoAt(seg.index, sampleN, segT);
    let slope = info.slope ?? 0;
    if (info.section === 'A') {
      slope = info.slopeA ?? slope;
    } else if (info.section === 'B') {
      slope = info.slopeB ?? slope;
    } else {
      const slopeA = info.slopeA ?? 0;
      const slopeB = info.slopeB ?? 0;
      const coverageA = info.coverageA ?? 0;
      const coverageB = info.coverageB ?? 0;
      const totalCoverage = coverageA + coverageB;
      if (totalCoverage > 1e-6) {
        slope = (coverageA * slopeA + coverageB * slopeB) / totalCoverage;
      }
    }
    const angleDeg = -(180 / Math.PI) * Math.atan(slope);
    return clamp(cfgTilt.tiltDir * angleDeg, -cfgTiltAdd.tiltAddMaxDeg, cfgTiltAdd.tiltAddMaxDeg);
  }

  // ---------- NPCs ----------
  const NPC = { total: 20, edgePad: 0.02, avoidLookaheadSegs: 20 };
  const CAR_TYPES = ['CAR','SEMI'];
  const cars = [];
  function carHalfWN(car) { return car.meta.wN * 0.5; }
  function npcLateralLimit(segIndex, car) {
    const half = carHalfWN(car);
    const base = 1 - half - NPC.edgePad;
    const seg = segmentAtIndex(segIndex);
    if (seg && seg.features && seg.features.rail) {
      const railInner = TUNE_TRACK.railInset - half - NPC.edgePad;
      return Math.min(base, railInner);
    }
    return base;
  }
  function spawnCars(){
    cars.length = 0;
    for (let i=0;i<NPC.total;i++){
      const s = Math.floor(Math.random() * Math.max(1, segments.length)) * segmentLength;
      const type = CAR_TYPES[Math.random()<0.75?0:1];
      const meta = SPRITE_META[type];
      const tmpCar = { type, meta };
      const seg = segmentAtS(s);
      const b = npcLateralLimit(seg.index, tmpCar);
      const side = (Math.random() < 0.5 ? -1 : 1);
      const offset = side * (Math.random() * (b * 0.9));
      const isSemi = (type==='SEMI');
      const speed = (TUNE_PLAYER.maxSpeed/6) + Math.random()*TUNE_PLAYER.maxSpeed/(isSemi?5:3);
      const car = { z:s, offset, type, meta, speed };
      seg.cars.push(car);
      cars.push(car);
    }
  }
  function tickCars(dt){
    const playerSeg = segmentAtS(phys.s);
    for (let n=0; n<cars.length; n++){
      const car = cars[n];
      const oldSeg = segmentAtS(car.z);
      car.offset += steerAvoidance(car, oldSeg, playerSeg, playerHalfWN());
      car.z = wrapDistance(car.z, dt*car.speed, trackLength);
      const newSeg = segmentAtS(car.z);
      if (oldSeg !== newSeg){
        const idx = oldSeg.cars.indexOf(car);
        if (idx>=0) oldSeg.cars.splice(idx,1);
        newSeg.cars.push(car);
      }
      const bNext = npcLateralLimit(newSeg.index, car);
      car.offset = clamp(car.offset, -bNext, bNext);
    }
  }
  function steerAvoidance(car, carSeg, playerSeg, playerW){
    const cHalf = carHalfWN(car);
    const lookahead = NPC.avoidLookaheadSegs;
    if ((carSeg.index - playerSeg.index + segments.length) % segments.length > TUNE_TRACK.drawDistance)
      return 0;
    for (let i=1;i<lookahead;i++){
      const seg = segments[(carSeg.index + i) % segments.length];
      // avoid player
      if ((seg === playerSeg) && (car.speed > Math.abs(phys.vtan)) && overlap(playerN, playerW, car.offset, cHalf, 1.0)){
        let dir;
        if (playerN > 0.5) dir = -1;
        else if (playerN < -0.5) dir = 1;
        else dir = (car.offset > playerN) ? 1 : -1;
        return dir * (1/i) * (car.speed - Math.abs(phys.vtan)) / TUNE_PLAYER.maxSpeed;
      }
      // avoid other cars
      for (let j=0;j<seg.cars.length;j++){
        const other = seg.cars[j];
        if (other === car) continue;
        if ((car.speed > other.speed) && overlap(car.offset, cHalf, other.offset, carHalfWN(other), 1.0)){
          let dir;
          if (other.offset > 0.5) dir = -1;
          else if (other.offset < -0.5) dir = 1;
          else dir = (car.offset > other.offset) ? 1 : -1;
          return dir * (1/i) * (car.speed - other.speed) / TUNE_PLAYER.maxSpeed;
        }
      }
    }
    const b = npcLateralLimit(carSeg.index, car);
    if (car.offset < -b) return Math.min(0.15, (-b - car.offset) * 0.6);
    if (car.offset >  b) return -Math.min(0.15, (car.offset - b) * 0.6);
    return 0;
  }

  // ---------- Props / pickups ----------
  function addProp(segIdx, kind, offset){ segments[segIdx].sprites.push({ kind, offset }); }
  function spawnProps(){
    for (let i=8; i<segments.length; i+=6){
      addProp(i, Math.random()<0.5 ? 'TREE' : 'PALM', -1.25 - Math.random()*0.15);
      addProp(i, Math.random()<0.5 ? 'TREE' : 'PALM',  1.25 + Math.random()*0.15);
      if (i % 12 === 0){
        addProp(i, 'SIGN', -1.05);
        addProp(i, 'SIGN',  1.05);
      }
      if (i % 18 === 0){
        const extra = 1.6 + Math.random()*1.6;
        addProp(i, Math.random()<0.5 ? 'TREE' : 'PALM', -extra);
        addProp(i, Math.random()<0.5 ? 'TREE' : 'PALM',  extra);
      }
    }
  }

  let pickupCollected = 0;
  let pickupTotal = 0;
  function addPickup(segIdx, offset=0){ segments[segIdx % segments.length].pickups.push({ offset, collected:false }); }
  function addPickupTrail(startSeg, count, spacing=2, offset=0){ for (let i=0;i<count;i++) addPickup(startSeg + i*spacing, offset); }
  function spawnPickups(){
    for (const s of segments) s.pickups.length = 0;
    pickupCollected = 0;
    const boostSegments = segments.filter(seg => seg.features && seg.features.boost);
    if (boostSegments.length > 0) {
      for (const seg of boostSegments) {
        const offset = (seg.features && seg.features.boostPickupOffset != null)
          ? seg.features.boostPickupOffset
          : 0;
        addPickup(seg.index, offset);
      }
    } else {
      addPickupTrail(12, 24, 2, 0.00);
      addPickupTrail(80, 30, 2, -0.35);
      addPickupTrail(140, 30, 2, 0.35);
      addPickupTrail(segments.length>>1, 16, 1, 0.0);
    }
    pickupTotal = segments.reduce((acc,s)=>acc+s.pickups.length, 0);
  }
  function resolvePickupCollisionsInSeg(seg){
    if (!seg || !seg.pickups || seg.pickups.length===0) return;
    const pHalf = playerHalfWN();
    const pickHalf = SPRITE_META.PICKUP.wN * 0.5;
    for (const p of seg.pickups){
      if (p.collected) continue;
      if (overlap(playerN, pHalf, p.offset, pickHalf, 1.0)){
        p.collected = true;
        pickupCollected++;
      }
    }
  }
  function resolveCollisions(){
    const pHalf = playerHalfWN();
    const playerSeg = segmentAtS(phys.s);
    // vehicles
    for (let i=0;i<playerSeg.cars.length;i++){
      const car = playerSeg.cars[i];
      if (Math.abs(phys.vtan) > car.speed){
        if (overlap(playerN, pHalf, car.offset, carHalfWN(car), 1.0)){
          phys.vtan = car.speed * (car.speed / Math.max(1, Math.abs(phys.vtan)));
          phys.s = wrapDistance(car.z, -2, trackLength);
          break;
        }
      }
    }
    // pickups (current and neighbors)
    resolvePickupCollisionsInSeg(playerSeg);
    resolvePickupCollisionsInSeg(segments[(playerSeg.index+1)%segments.length]);
    resolvePickupCollisionsInSeg(segments[(playerSeg.index-1+segments.length)%segments.length]);
  }

  // ---------- Renderer ----------
  function renderScene(){
    glr.begin([0.9,0.95,1.0,1]);

    const sCar = phys.s;
    const sCam = sCar - TUNE_TRACK.camBackSegments*segmentLength;
    const camX = playerN*roadWidthAt(sCar);
    const camY = camYSmooth;

    // world roll & car tilt
    {
      const bodyTmp = { world:{x:camX, y:phys.y, z:sCar}, camera:{}, screen:{} };
      projectPoint(bodyTmp, camX, camY, sCam);
      const speedPct = clamp(Math.abs(phys.vtan)/TUNE_PLAYER.maxSpeed, 0, 1);
      const segAhead = segmentAtS(phys.s + playerZ);
      const curveNorm = clamp(segAhead.curve / 6, -1, 1);
      const combined = clamp(lateralRate * cfgTilt.tiltSens + curveNorm * cfgTilt.tiltCurveWeight, -1, 1);
      const baseTargetDeg = cfgTilt.tiltDir * clamp(combined * speedPct, -1, 1) * cfgTilt.tiltMaxDeg;
      camRollDeg += (baseTargetDeg - camRollDeg) * cfgTilt.tiltEase;
      const pivotX = W * 0.5;
      const pivotY = Math.min(bodyTmp.screen.y + 12, H*0.95);
      glr.setRollPivot((camRollDeg * Math.PI/180), pivotX, pivotY);
      const cliffDeg = getAdditiveTiltDeg();
      playerTiltDeg += (cliffDeg - playerTiltDeg) * 0.35;
    }

    renderHorizon();

    const baseSeg = segmentAtS(sCam);
    const basePct = pctRem(sCam, segmentLength);

    const drawList=[];
    let x=0, dx=-(baseSeg.curve*basePct);

    for(let n=0;n<TUNE_TRACK.drawDistance;n++){
      const idx=(baseSeg.index+n)%segments.length;
      const seg=segments[idx];
      const looped = seg.index < baseSeg.index;
      const camSRef = sCam - (looped ? trackLength : 0);

      const p1 ={world:{...seg.p1.world},camera:{},screen:{}};
      const p2 ={world:{...seg.p2.world},camera:{},screen:{}};
      projectPoint(p1,  camX - x,      camY, camSRef);
      projectPoint(p2,  camX - x - dx, camY, camSRef);

      x += dx; dx += seg.curve; // curve is 0 for straight
      if (p1.camera.z <= nearZ) continue;

      const depth = Math.max(p1.camera.z, p2.camera.z);
      const visibleRoad = (p2.screen.y < p1.screen.y);

      const rw1 = roadWidthAt(p1.world.z), rw2 = roadWidthAt(p2.world.z);
      const w1 = p1.screen.scale * rw1 * HALF_VIEW;
      const w2 = p2.screen.scale * rw2 * HALF_VIEW;

      const f1Road = fogFactorFromZ(p1.camera.z);
      const f2Road = fogFactorFromZ(p2.camera.z);
      const fogRoad = [f1Road,f1Road,f2Road,f2Road];

      const yScale1 = 1.0 - f1Road;
      const yScale2 = 1.0 - f2Road;

      const boostZonesHere = boostZonesOnSegment(seg);

      const cliffStart = cliffParamsAt(idx, 0);
      const cliffEnd   = cliffParamsAt(idx, 1);

      const dyLA1 = cliffStart.leftA.dy;
      const dyLA2 = cliffEnd.leftA.dy;
      const dyLB1 = cliffStart.leftA.dy + cliffStart.leftB.dy;
      const dyLB2 = cliffEnd.leftA.dy + cliffEnd.leftB.dy;

      const dyRA1 = cliffStart.rightA.dy;
      const dyRA2 = cliffEnd.rightA.dy;
      const dyRB1 = cliffStart.rightA.dy + cliffStart.rightB.dy;
      const dyRB2 = cliffEnd.rightA.dy + cliffEnd.rightB.dy;

      const p1LA={world:{x:0,y:seg.p1.world.y + dyLA1 * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2LA={world:{x:0,y:seg.p2.world.y + dyLA2 * yScale2, z:seg.p2.world.z},camera:{},screen:{}};
      const p1LB={world:{x:0,y:seg.p1.world.y + dyLB1 * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2LB={world:{x:0,y:seg.p2.world.y + dyLB2 * yScale2, z:seg.p2.world.z},camera:{},screen:{}};
      const p1RA={world:{x:0,y:seg.p1.world.y + dyRA1 * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2RA={world:{x:0,y:seg.p2.world.y + dyRA2 * yScale2, z:seg.p2.world.z},camera:{},screen:{}};
      const p1RB={world:{x:0,y:seg.p1.world.y + dyRB1 * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2RB={world:{x:0,y:seg.p2.world.y + dyRB2 * yScale2, z:seg.p2.world.z},camera:{},screen:{}};

      projectPoint(p1LA, camX - x,      camY, camSRef);
      projectPoint(p2LA, camX - x - dx, camY, camSRef);
      projectPoint(p1LB, camX - x,      camY, camSRef);
      projectPoint(p2LB, camX - x - dx, camY, camSRef);
      projectPoint(p1RA, camX - x,      camY, camSRef);
      projectPoint(p2RA, camX - x - dx, camY, camSRef);
      projectPoint(p1RB, camX - x,      camY, camSRef);
      projectPoint(p2RB, camX - x - dx, camY, camSRef);

      // NEW: world-space tops for short rails
      const p1LS={world:{x:0,y:seg.p1.world.y + TUNE_TRACK.wallShortLeft  * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2LS={world:{x:0,y:seg.p2.world.y + TUNE_TRACK.wallShortLeft  * yScale2, z:seg.p2.world.z},camera:{},screen:{}};
      const p1RS={world:{x:0,y:seg.p1.world.y + TUNE_TRACK.wallShortRight * yScale1, z:seg.p1.world.z},camera:{},screen:{}};
      const p2RS={world:{x:0,y:seg.p2.world.y + TUNE_TRACK.wallShortRight * yScale2, z:seg.p2.world.z},camera:{},screen:{}};
      projectPoint(p1LS, camX - x,      camY, camSRef);
      projectPoint(p2LS, camX - x - dx, camY, camSRef);
      projectPoint(p1RS, camX - x,      camY, camSRef);
      projectPoint(p2RS, camX - x - dx, camY, camSRef);

      const L = makeCliffLeftQuads(
        p1.screen.x, p1.screen.y, w1,
        p2.screen.x, visibleRoad ? p2.screen.y : (p1.screen.y-1),
        w2,
        p1LA.screen.y, p2LA.screen.y,
        p1LB.screen.y, p2LB.screen.y,
        cliffStart.leftA.dx, cliffEnd.leftA.dx,
        cliffStart.leftB.dx, cliffEnd.leftB.dx,
        0, 1,
        rw1, rw2
      );
      const R = makeCliffRightQuads(
        p1.screen.x, p1.screen.y, w1,
        p2.screen.x, visibleRoad ? p2.screen.y : (p1.screen.y-1),
        w2,
        p1RA.screen.y, p2RA.screen.y,
        p1RB.screen.y, p2RB.screen.y,
        cliffStart.rightA.dx, cliffEnd.rightA.dx,
        cliffStart.rightB.dx, cliffEnd.rightB.dx,
        0, 1,
        rw1, rw2
      );

      // per-surface tiling spans
      const [v0Road,  v1Road ] = vSpanForSeg(roadTexZones,  idx);
      const [v0Rail,  v1Rail ] = vSpanForSeg(railTexZones,  idx);
      const [v0Cliff, v1Cliff] = vSpanForSeg(cliffTexZones, idx);

      // push strip
      drawList.push({ type:'strip', depth,
        segIndex:idx, seg, visibleRoad,
        boostZones: boostZonesHere,
        p1, p2, w1, w2, rw1, rw2,
        L, R,
        v0Road, v1Road, v0Rail, v1Rail, v0Cliff, v1Cliff,
        fogRoad,
        // NEW tops for rails
        p1LS, p2LS, p1RS, p2RS
      });

      // NPCs
      for (let i=0;i<seg.cars.length;i++){
        const car = seg.cars[i];
        const t = ((car.z - seg.p1.world.z + trackLength) % trackLength) / segmentLength;
        const scale = lerp(p1.screen.scale, p2.screen.scale, t);
        const rw = lerp(rw1, rw2, t);
        const xCenter = lerp(p1.screen.x, p2.screen.x, t) + (scale * car.offset * rw * HALF_VIEW);
        const yBase   = lerp(p1.screen.y, p2.screen.y, t);
        const zObj = lerp(p1.camera.z, p2.camera.z, t);
        const farS = spriteFarScaleFromZ(zObj);
        let wPx = Math.max(6, scale * car.meta.wN * rw * HALF_VIEW);
        let hPx = Math.max(10, wPx * car.meta.aspect);
        wPx *= farS; hPx *= farS;
        drawList.push({ type:'npc', depth:zObj, x:xCenter, y:yBase, w:wPx, h:hPx, z:zObj, tint:car.meta.tint, tex:(car.meta.tex?car.meta.tex():null) });
      }

      // props (near end only for speed)
      for (let i=0;i<seg.sprites.length;i++){
        const spr = seg.sprites[i];
        const meta = SPRITE_META[spr.kind] || SPRITE_META.SIGN;
        const scale = p1.screen.scale;
        const sAbs = Math.abs(spr.offset);
        let xCenter, yBase;
        if (sAbs <= 1.0){
          xCenter = p1.screen.x + (scale * spr.offset * rw1 * HALF_VIEW);
          yBase   = p1.screen.y;
        } else {
          const sideLeft = spr.offset < 0;
          const o = Math.min(2, Math.max(0, sAbs - 1.0));
          if (sideLeft){
            const xInner = L.x1_inner, xA = L.x1_A, xB = L.x1_B;
            const yInner = p1.screen.y, yA = p1LA.screen.y, yB = p1LB.screen.y;
            if (o <= 1){ xCenter = lerp(xInner, xA, o); yBase = lerp(yInner, yA,  o); }
            else { const t2 = o-1; xCenter = lerp(xA, xB, t2); yBase = lerp(yA, yB, t2); }
          } else {
            const xInner = R.x1_inner, xA = R.x1_A, xB = R.x1_B;
            const yInner = p1.screen.y, yA = p1RA.screen.y, yB = p1RB.screen.y;
            if (o <= 1){ xCenter = lerp(xInner, xA, o); yBase = lerp(yInner, yA,  o); }
            else { const t2 = o-1; xCenter = lerp(xA, xB, t2); yBase = lerp(yA, yB, t2); }
          }
        }
        const zObj = p1.camera.z + 1e-3;
        const farS = spriteFarScaleFromZ(zObj);
        let wPx = Math.max(6, scale * meta.wN * rw1 * HALF_VIEW);
        let hPx = Math.max(10, wPx * meta.aspect);
        wPx *= farS; hPx *= farS;
        drawList.push({ type:'prop', depth:zObj, x:xCenter, y:yBase, w:wPx, h:hPx, z:zObj, tint:meta.tint, tex:(meta.tex?meta.tex():null) });
      }

      // pickups (near end only)
      if (seg.pickups && seg.pickups.length){
        for (const pk of seg.pickups){
          if (pk.collected) continue;
          const scale = p1.screen.scale;
          const xCenter = p1.screen.x + (scale * pk.offset * rw1 * HALF_VIEW);
          const yBase   = p1.screen.y;
          const meta = SPRITE_META.PICKUP;
          const zObj = p1.camera.z + 1e-3;
          const farS = spriteFarScaleFromZ(zObj);
          let wPx = Math.max(6, scale * meta.wN * rw1 * HALF_VIEW);
          let hPx = Math.max(6, wPx * meta.aspect);
          wPx *= farS; hPx *= farS;
          drawList.push({ type:'pickup', depth:zObj, x:xCenter, y:yBase, w:wPx, h:hPx, z:zObj, tint:meta.tint, tex:(meta.tex?meta.tex():null) });
        }
      }
    }

    // player sprite
    {
      const carX=playerN*roadWidthAt(phys.s);
      const floor = floorElevationAt(phys.s, playerN);
      const bodyYWorld   = phys.grounded ? floor : phys.y;
      const shadowYWorld = floor;
      const body   ={world:{x:carX,y:bodyYWorld,   z:phys.s},camera:{},screen:{}};
      const shadow ={world:{x:carX,y:shadowYWorld, z:phys.s},camera:{},screen:{}};
      projectPoint(body, camX, camY, sCam); projectPoint(shadow, camX, camY, sCam);
      if(body.camera.z > nearZ){
        const pixScale = body.screen.scale * HALF_VIEW;
        const w = Math.max(12, (SPRITE_META.PLAYER.wN * getKindScale('PLAYER') * roadWidthAt(phys.s)) * pixScale);
        const h = Math.max(18, w * SPRITE_META.PLAYER.aspect);
        drawList.push({
          type:'player', depth: body.camera.z-1e-3,
          x: body.screen.x, w, h,
          bodyY: body.screen.y,
          shadowY: shadow.screen.y,
          zBody: body.camera.z,
          zShadow: shadow.camera.z
        });
      }
    }

    // depth sort
    drawList.sort((a,b)=> b.depth - a.depth);

    // draw pass
    for(const it of drawList){
      if(it.type==='strip'){
        const { p1, p2, w1, w2, rw1, rw2, L, R,
                v0Road, v1Road, v0Rail, v1Rail, v0Cliff, v1Cliff,
                fogRoad, visibleRoad, segIndex, seg,
                boostZones,
                p1LS, p2LS, p1RS, p2RS } = it;
        const x1=p1.screen.x, y1=p1.screen.y;
        const x2=p2.screen.x, y2=(visibleRoad?p2.screen.y:(p1.screen.y-1));

        // order: cliffs behind/in front
        const leftAvgY  = 0.25*(L.quadA.y1 + L.quadA.y4 + L.quadB.y1 + L.quadB.y4);
        const rightAvgY = 0.25*(R.quadA.y2 + R.quadA.y3 + R.quadB.y2 + R.quadB.y3);
        const roadMidY  = 0.5*(y1 + y2);
        const leftIsNegative  = (leftAvgY  > roadMidY);
        const rightIsNegative = (rightAvgY > roadMidY);

        // fog (use road ends for both A/B)
        const fNear = fogFactorFromZ(p1.camera.z);
        const fFar  = fogFactorFromZ(p2.camera.z);
        const fogCliff = [fNear,fNear,fFar,fFar];

        const group = ((segIndex/DEBUG.span)|0) % 2;
        const tint  = group ? DEBUG.colors.a : DEBUG.colors.b;

        const cliffTex = textures.cliff || glr.whiteTex;

        const L_A = padQuad(L.quadA, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });
        const L_B = padQuad(L.quadB, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });
        const R_A = padQuad(R.quadA, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });
        const R_B = padQuad(R.quadB, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });

        const drawLeftCliffs = (solid=false) => {
          const uvA = {...L.uvA, v1:v0Cliff, v2:v0Cliff, v3:v1Cliff, v4:v1Cliff};
          const uvB = {...L.uvB, v1:v0Cliff, v2:v0Cliff, v3:v1Cliff, v4:v1Cliff};
          if (solid) {
            glr.drawQuadSolid(L_A, tint, fogCliff);
            glr.drawQuadSolid(L_B, tint, fogCliff);
          } else {
            glr.drawQuadTextured(cliffTex, L_A, uvA, DEFAULT_COLORS.wall, fogCliff);
            glr.drawQuadTextured(cliffTex, L_B, uvB, DEFAULT_COLORS.wall, fogCliff);
          }
        };
        const drawRightCliffs = (solid=false) => {
          const uvA = {...R.uvA, v1:v0Cliff, v2:v0Cliff, v3:v1Cliff, v4:v1Cliff};
          const uvB = {...R.uvB, v1:v0Cliff, v2:v0Cliff, v3:v1Cliff, v4:v1Cliff};
          if (solid) {
            glr.drawQuadSolid(R_A, tint, fogCliff);
            glr.drawQuadSolid(R_B, tint, fogCliff);
          } else {
            glr.drawQuadTextured(cliffTex, R_A, uvA, DEFAULT_COLORS.wall, fogCliff);
            glr.drawQuadTextured(cliffTex, R_B, uvB, DEFAULT_COLORS.wall, fogCliff);
          }
        };

        const debugFill = (DEBUG.mode === 'fill');

        if (leftIsNegative)  drawLeftCliffs(debugFill);
        if (rightIsNegative) drawRightCliffs(debugFill);

        if (debugFill){
          const quad = { x1:x1-w1, y1:y1, x2:x1+w1, y2:y1, x3:x2+w2, y3:y2, x4:x2-w2, y4:y2 };
          glr.drawQuadSolid(quad, tint, fogRoad);
        } else {
          const roadTex = textures.road || glr.whiteTex;
          drawRoadStrip(x1,y1,w1, x2,y2,w2, v0Road, v1Road, fogRoad, roadTex);
          drawBoostZonesOnStrip(boostZones, x1, y1, x2, y2, w1, w2, fogRoad);
        }

        if (!leftIsNegative)  drawLeftCliffs(debugFill);
        if (!rightIsNegative) drawRightCliffs(debugFill);

        // guardrails — world-space short walls (projected like cliffs)
        if (seg && seg.features && seg.features.rail) {
          const texRail = textures.rail || glr.whiteTex;

          // Left rail: inner x at road edge, top y from p1LS/p2LS
          const xL1 = x1 - w1 * TUNE_TRACK.railInset;
          const xL2 = x2 - w2 * TUNE_TRACK.railInset;

          const quadL = {
            x1: xL1, y1: p1LS.screen.y,
            x2: xL1, y2: y1,
            x3: xL2, y3: y2,
            x4: xL2, y4: p2LS.screen.y
          };
          const uvL = { u1:0, v1:v0Rail, u2:1, v2:v0Rail, u3:1, v3:v1Rail, u4:0, v4:v1Rail };
          const fLs1 = fogFactorFromZ(p1LS.camera.z), fLs2 = fogFactorFromZ(p2LS.camera.z);
          const quadL_p = padQuad(quadL, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });
          glr.drawQuadTextured(texRail, quadL_p, uvL, DEFAULT_COLORS.rail, [fLs1,fLs1,fLs2,fLs2]);

          // Right rail
          const xR1 = x1 + w1 * TUNE_TRACK.railInset;
          const xR2 = x2 + w2 * TUNE_TRACK.railInset;

          const quadR = {
            x1: xR1, y1: y1,
            x2: xR1, y2: p1RS.screen.y,
            x3: xR2, y3: p2RS.screen.y,
            x4: xR2, y4: y2
          };
          const uvR = { u1:0, v1:v0Rail, u2:1, v2:v0Rail, u3:1, v3:v1Rail, u4:0, v4:v1Rail };
          const fRs1 = fogFactorFromZ(p1RS.camera.z), fRs2 = fogFactorFromZ(p2RS.camera.z);
          const quadR_p = padQuad(quadR, { padLeft:OVERLAP.x, padRight:OVERLAP.x, padTop:OVERLAP.y, padBottom:OVERLAP.y });
          glr.drawQuadTextured(texRail, quadR_p, uvR, DEFAULT_COLORS.rail, [fRs1,fRs1,fRs2,fRs2]);
        }

      } else if (it.type==='npc' || it.type==='prop'){
        drawBillboard(it.x, it.y, it.w, it.h, it.z, it.tint, it.tex);
      } else if (it.type==='pickup'){
        drawBillboard(it.x, it.y - it.h*0.2, it.w, it.h, it.z, it.tint, it.tex);
      } else if (it.type==='player'){
        const fShadow = fogFactorFromZ(it.zShadow||0);
        const fBody   = fogFactorFromZ(it.zBody||0);
        const shH = Math.max(3, it.h * 0.06);

        const bodyBottom = Math.min(it.bodyY, it.shadowY - shH);
        const bodyTop    = bodyBottom - it.h;
        const bodyCX = it.x;
        const bodyCY = (bodyTop + bodyBottom) * 0.5;
        const shCX   = it.x;
        const shCY   = it.shadowY - shH * 0.5;

        const ang = (playerTiltDeg * Math.PI) / 180;

        const shQuad = makeRotatedQuad(shCX, shCY, it.w, shH, ang);
        glr.drawQuadSolid(shQuad, [0.13,0.13,0.13,1], [fShadow,fShadow,fShadow,fShadow]);

        const bodyQuad = makeRotatedQuad(bodyCX, bodyCY, it.w, it.h, ang);
        glr.drawQuadSolid(bodyQuad, SPRITE_META.PLAYER.tint, [fBody,fBody,fBody,fBody]);
      }
    }

    glr.end();
  }

  // ---------- Side overlay ----------
  function worldToOverlay(s,y){
    return {
      x:(s-phys.s)*(1/TUNE_TRACK.MPerPxX) + SW*0.5,
      y: SH - y*(1/TUNE_TRACK.MPerPxY) - 60
    };
  }
  function drawBoostCrossSection(ctx){
    const panelX = 24;
    const panelY = 24;
    const panelW = 220;
    const panelH = 120;
    const roadPadX = 18;
    const roadPadTop = 24;
    const roadPadBottom = 20;
    const roadW = panelW - roadPadX * 2;
    const roadH = panelH - roadPadTop - roadPadBottom;

    ctx.save();
    ctx.translate(panelX, panelY);

    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0, 0, panelW, panelH);

    const roadX = roadPadX;
    const roadY = roadPadTop;
    ctx.fillStyle = '#484848';
    ctx.fillRect(roadX, roadY, roadW, roadH);
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.strokeRect(roadX, roadY, roadW, roadH);

    const seg = segmentAtS(phys.s);
    const zones = boostZonesOnSegment(seg);
    const mapN = (n, fallback = 0) => {
      const ratio = laneToRoadRatio(n, fallback);
      return roadX + ratio * roadW;
    };

    for (const zone of zones){
      if (zone && zone.visible === false) continue;
      const colors = BOOST_ZONE_COLORS[zone.type] || BOOST_ZONE_FALLBACK_COLOR;
      const fallbackStart = clampBoostLane(-2);
      const fallbackEnd = clampBoostLane(2);
      const x1 = mapN(zone.nStart, fallbackStart);
      const x2 = mapN(zone.nEnd, fallbackEnd);
      const zx = Math.min(x1, x2);
      const zw = Math.max(2, Math.abs(x2 - x1));
      ctx.fillStyle = colors.fill;
      ctx.fillRect(zx, roadY, zw, roadH);
      ctx.strokeStyle = colors.stroke;
      ctx.lineWidth = 2;
      ctx.strokeRect(zx, roadY, zw, roadH);
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    const centerX = mapN(0);
    ctx.beginPath();
    ctx.moveTo(centerX, roadY);
    ctx.lineTo(centerX, roadY + roadH);
    ctx.stroke();

    const playerX = mapN(playerN);
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(playerX, roadY + roadH * 0.5, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = '#ffffff';
    ctx.font = '11px system-ui, Arial';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Cross-section', 0, panelH - 4);

    ctx.restore();
  }
  function renderOverlay(){
    if (!overlayOn) return;
    const ctx = ctxSide;
    ctx.clearRect(0,0,SW,SH);
    ctx.lineWidth = 2;
    ctx.strokeStyle = phys.boostFlashTimer>0 ? '#d32f2f' : '#1976d2';
    ctx.beginPath();
    const sStart = phys.s - SW*0.5*TUNE_TRACK.MPerPxX;
    const sEnd   = phys.s + SW*0.5*TUNE_TRACK.MPerPxX;
    const step   = Math.max(5, 2*TUNE_TRACK.MPerPxX);
    let first = true;
    for (let s = sStart; s <= sEnd; s += step){
      const p = worldToOverlay(s, elevationAt(s));
      if (first){ ctx.moveTo(p.x,p.y); first=false; } else { ctx.lineTo(p.x,p.y); }
    }
    ctx.stroke();

    drawBoostCrossSection(ctx);

    const p = worldToOverlay(phys.s, phys.y);
    ctx.fillStyle = '#2e7d32';
    ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();

    const { dy, d2y } = groundProfileAt(phys.s);
    const kap = computeCurvature(dy, d2y);
    const boostingHUD = (boostTimer>0) ? `boost:${boostTimer.toFixed(2)}s ` : '';
    const driftHUD = `drift:${driftState}${driftState==='drifting'?' dir='+driftDirSnapshot:''} charge:${driftCharge.toFixed(2)}/${DRIFT.boostChargeMin} armed:${allowedBoost}`;
    const hud = `${boostingHUD}${driftHUD}  vtan:${phys.vtan.toFixed(1)}  grounded:${phys.grounded}  kappa:${kap.toFixed(5)}  n:${playerN.toFixed(2)}  cars:${cars.length}  pickups:${pickupCollected}/${pickupTotal}`;
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.font = '12px system-ui, Arial';
    ctx.strokeText(hud, 10, SH-12);
    ctx.fillText(hud, 10, SH-12);
  }

  // ---------- Reset matte ----------
  const resetMatte = (() => {
    const FR_SHRINK = 32, FR_WAIT = 10, FR_EXPAND = 34, FR_TOTAL = FR_SHRINK + FR_WAIT + FR_EXPAND;
    let active = false, t = 0, scale = 1, didAction = false, mode = 'reset';
    let respawnS = 0, respawnN = 0;
    function start(nextMode='reset', sForRespawn=null, nForRespawn=0){
      if (active) return;
      active = true; t = 0; scale = 1; didAction = false; mode = nextMode;
      if (nextMode === 'respawn') { respawnS = (sForRespawn == null) ? phys.s : sForRespawn; respawnN = nForRespawn; }
    }
    function tick(){
      if (!active) return;
      if (t < FR_SHRINK) scale = 1 - (t + 1) / FR_SHRINK;
      else if (t < FR_SHRINK + FR_WAIT) scale = 0;
      else if (t < FR_TOTAL) { const u = t - (FR_SHRINK + FR_WAIT); scale = (u + 1) / FR_EXPAND; }
      if (!didAction && t >= FR_SHRINK) {
        if (mode === 'reset') resetScene().catch(err=>console.error(err)); else respawnPlayerAt(respawnS, respawnN);
        didAction = true;
      }
      t++; if (t >= FR_TOTAL) { active = false; scale = 1; didAction = false; ctxHUD.clearRect(0,0,HUD_W,HUD_H); }
    }
    function draw(){
      if (!active) return;
      ctxHUD.clearRect(0,0,HUD_W,HUD_H);
      ctxHUD.fillStyle = '#000';
      ctxHUD.fillRect(0,0,HUD_W,HUD_H);
      const r = HUD_COVER_RADIUS * scale;
      if (r > 0){
        ctxHUD.save(); ctxHUD.globalCompositeOperation = 'destination-out';
        ctxHUD.beginPath(); ctxHUD.arc(HUD_W*0.5, HUD_H*0.5, r, 0, Math.PI*2); ctxHUD.fill();
        ctxHUD.restore();
      }
    }
    return { start, tick, draw, get active(){ return active; } };
  })();
  function queueReset(){ resetMatte.start('reset'); }
  function queueRespawn(sAtFail){ const targetS = nearestSegmentCenter(sAtFail); resetMatte.start('respawn', targetS, 0); }

  function respawnPlayerAt(sTarget, nNorm = 0) {
    phys.s = (sTarget % trackLength + trackLength) % trackLength;
    phys.y = elevationAt(phys.s);
    phys.grounded = true;
    phys.vx = 0; phys.vy = 0; phys.vtan = 0;
    const segIdx = segmentAtS(phys.s).index;
    const bound = playerLateralLimit(segIdx);
    playerN = clamp(nNorm, -bound, bound);
    camYSmooth = phys.y + TUNE_TRACK.cameraHeight;
    hopHeld = false; driftState = 'idle'; driftDirSnapshot = 0; driftCharge = 0; allowedBoost = false; boostTimer = 0;
  }

  // ---------- Reset & main loop ----------
  async function resetScene(){
    fieldOfView  = TUNE_TRACK.fov;
    cameraDepth  = 1/Math.tan((fieldOfView/2)*Math.PI/180);
    nearZ        = 1 / cameraDepth;
    playerZ      = TUNE_TRACK.cameraHeight*cameraDepth;

    try {
      await buildTrackFromCSV('tracks/test-track.csv');
    } catch (err) {
      console.warn('CSV build failed, using fallback', err);
      segments.length = 0;
      boostZoneIdCounter = 0;
      addRoad(25,25,25,0,0,'smooth');
      addRoad(50,50,50,2,20,'smooth');
      addRoad(40,40,40,0,60,'smooth');
      addRoad(100,80,60,-4,-20,'smooth');
      addRoad(25,25,25,0,0,'smooth');
      trackLength = segments.length * segmentLength;
    }

    // NEW: prepare per-segment cliff arrays and load compact CSV
    resetCliffSeries();
    await buildCliffsFromCSV_Lite('tracks/cliffs.csv').catch(()=>{});
    enforceCliffWrap(1); // make index 0 == index N-1 for each series

    // Default zones: whole track
    roadTexZones.length = railTexZones.length = cliffTexZones.length = 0;
    pushZone(roadTexZones,  0, segments.length-1, 20);
    pushZone(railTexZones,  0, segments.length-1, 20);
    pushZone(cliffTexZones, 0, segments.length-1, 3);

    spawnProps();
    spawnCars();
    spawnPickups();

    phys.s = TUNE_TRACK.camBackSegments*segmentLength;
    phys.y = elevationAt(phys.s);
    phys.vx = phys.vy = phys.vtan = 0;
    phys.grounded = true;
    phys.t = 0;
    phys.nextHopTime = 0;
    phys.boostFlashTimer = 0;
    playerN = 0;
    camYSmooth = phys.y + TUNE_TRACK.cameraHeight;
    hopHeld=false; driftState='idle'; driftDirSnapshot=0; driftCharge=0; allowedBoost=false; boostTimer=0;
    camRollDeg = 0; playerTiltDeg = 0; prevPlayerN = playerN; lateralRate = 0;
  }

  const fps = 60, step = 1/fps;
  let last=performance.now(), acc=0;
  function frame(now){
    const dt=Math.min(0.25,(now-last)/1000); last=now; acc+=dt;
    while(acc>=step){
      updatePhysics(step);
      tickCars(step);
      resetMatte.tick();
      acc-=step;
    }
    renderScene();
    renderOverlay();
    resetMatte.draw();
    if (phys.boostFlashTimer>0) phys.boostFlashTimer=Math.max(0, phys.boostFlashTimer - dt);
    requestAnimationFrame(frame);
  }
  (async () => {
    await resetScene();
    requestAnimationFrame(frame);
  })();
})();
</script>
</html>
