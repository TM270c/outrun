<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Straight Track — 2.5D + Drift + Fog + Cliffs + Sprites + Guardrails</title>
<style>
  html,body{margin:0;background:#0f1a0f}
  .wrap{display:flex;gap:16px;justify-content:center;align-items:center;height:100vh}
  .stack{position:relative;width:1024px;height:768px;border:1px solid #2a2a2a;background:#ffffff}
  #outrun{position:absolute;left:0;top:0;width:1024px;height:768px;image-rendering:pixelated;image-rendering:crisp-edges;background:#ffffff}
  #sideOverlay{position:absolute;left:0;top:0;width:1024px;height:768px;background:transparent;pointer-events:none}
  #hudMatte{position:absolute;left:0;top:0;width:1024px;height:768px;image-rendering:pixelated;image-rendering:crisp-edges;background:transparent;pointer-events:none}
  .ui{position:fixed;left:50%;top:10px;transform:translateX(-50%);font:12px system-ui,Arial;background:#000c;color:#fff;padding:6px 10px;border-radius:10px}
</style>

<div class="wrap">
  <div class="stack">
    <canvas id="outrun" width="512" height="384" title="2.5D view (WebGL)"></canvas>
    <canvas id="sideOverlay" width="1024" height="768" title="Side overlay (B to toggle)"></canvas>
    <canvas id="hudMatte" width="512" height="384" title="HUD reset matte"></canvas>
  </div>
</div>
<div class="ui">←/→ steer · ↑ throttle · ↓ brake · SPACE hop (hold to drift) · R reset · B toggle overlay</div>

<script>
(() => {
  'use strict';

  // ---------------------------------------------------------------------------
  // (1) Config & Tunables (road, car, camera, input, rendering)
  // ---------------------------------------------------------------------------
  const CAR_CONFIG = Object.freeze({
    accelUnitsPerSec2: 3000,
    brakeUnitsPerSec2: 3000,
    gravityUnitsPerSec2: 6400,
    rollDragPerSec: 0.3,
    airDragPerSec: 0,
    maxSpeedUnitsPerSec: 7000,
    steerRateDegPerSec: 120,
    leanFromCentrifugal: 0.1,
    hopImpulseUnitsPerSec: 1400,
    hopCooldownSeconds: 0.25,
    crestBoostMultiplier: 1.25,
    sizeScale: 1,
  });

  const TRACK_CONFIG = Object.freeze({
    segmentLengthUnits: 200,
    roadHalfWidthUnits: 2400 / 2,
    drawDistanceSegments: 200,
    cameraFovDegrees: 140,
    cameraHeightUnits: 700,
    cameraLookBackSegments: 2,
    cameraHeightLerpTau: 0.1,
    cliffPushFraction: 0.5,
    cliffDistanceGain: 0.6,
    cliffCapPerFrame: 0.5,
    cameraCliffFraction: 1 / 3,
    failSafeBelowRoadUnits: 600,
    railInsetRatio: 0.95,
    railHeightLeftUnits: 400,
    railHeightRightUnits: 400,
    minLaneIndex: -2,
    maxLaneIndex: 2,
    boostLaneMin: -1,
    boostLaneMax: 1,
    boostSpeedAddUnitsPerSec: 1500,
  });

  const GRID_CONFIG = Object.freeze({
    maxNearColumns: 6,
    minFarColumns: 2,
    desiredColumnPixels: 96,
    desiredRowPixels: 18,
    maxRows: 64,
  });

  const DRIFT_CONFIG = Object.freeze({
    boostChargeMin: 0.60,
    boostTimeSeconds: 0.35,
    boostMultiplier: 1.8,
    boostSteerScale: 0.6,
    boostLockBase: 0.75,
    boostLockWith: 1.25,
    boostLockAgainst: 0.25,
  });

  const SPRITE_CONFIG = Object.freeze({ shrinkToScale: 0.1, perspectivePower: 0.4 });

  const FOG_CONFIG = Object.freeze({
    enabled: true,
    nearSegment: 0,
    farSegment: 160,
    color: [0.1, 0.5, 0.8],
  });

  const RENDER_COLORS = Object.freeze({
    road: [0.5, 0.5, 0.5, 1],
    wall: [0.5, 0.5, 0.5, 1],
    rail: [0.5, 0.5, 0.5, 1],
  });

  const DEBUG_CONFIG = Object.freeze({ mode: 'off', span: 3, colors: { a: [1, 1, 1, 1], b: [0.82, 0.90, 1, 1] } });

  const PARALLAX_LAYERS = Object.freeze([
    { key: 'horizon1', parallaxX: 0.05, uvSpanX: 1.0, uvSpanY: 1.0 },
    { key: 'horizon2', parallaxX: 0.10, uvSpanX: 1.0, uvSpanY: 1.0 },
    { key: 'horizon3', parallaxX: 0.18, uvSpanX: 1.0, uvSpanY: 1.0 },
  ]);

  const BOOST_ZONES = Object.freeze({
    types: Object.freeze({ jump: 'jump', drive: 'drive' }),
    effect: Object.freeze({ speedAdd: 1500 }),
    textures: Object.freeze({ jump: 'boostJump', drive: 'boostDrive' }),
    colors: Object.freeze({
      jump: { fill: 'rgb(255,152,0)', stroke: '#ff9800', solid: [1, 152 / 255, 0, 1] },
      drive: { fill: 'rgb(33,150,243)', stroke: '#2196f3', solid: [33 / 255, 150 / 255, 243 / 255, 1] },
      fallback: { fill: 'rgb(255,255,255)', stroke: '#fafafa', solid: [1, 1, 1, 1] },
    }),
  });

  const CAMERA_SHAKE = Object.freeze({
    hopRoll: 0.04,
    hopPitch: 0.02,
  });

  const INPUT_CONFIG = Object.freeze({
    keyboard: {
      steerLeft: ['ArrowLeft', 'KeyA'],
      steerRight: ['ArrowRight', 'KeyD'],
      throttle: ['ArrowUp', 'KeyW'],
      brake: ['ArrowDown', 'KeyS'],
      hop: ['Space'],
      reset: ['KeyR'],
      toggleOverlay: ['KeyB'],
    },
  });

  const RENDER_PIPELINE = Object.freeze({
    canvasWidth: 512,
    canvasHeight: 384,
    sideOverlayWidth: 1024,
    sideOverlayHeight: 768,
    hudWidth: 512,
    hudHeight: 384,
  });

  // ---------------------------------------------------------------------------
  // (2) Types & Utils (math, clamp/wrap/lerp, random, easing)
  // ---------------------------------------------------------------------------
  const TAU = Math.PI * 2;
  const HALF_PI = Math.PI / 2;

  const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smoothstep = (edge0, edge1, x) => {
    const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  };
  const wrap = (value, max) => {
    const m = value % max;
    return m < 0 ? m + max : m;
  };
  const approach = (value, target, delta) => {
    if (value < target) return Math.min(target, value + delta);
    if (value > target) return Math.max(target, value - delta);
    return target;
  };
  const withArray = (length, mapFn) => Array.from({ length }, (_, i) => mapFn(i));

  class RNG {
    constructor(seed = 1) {
      this.state = seed >>> 0;
    }
    next() {
      let x = this.state;
      x ^= x << 13;
      x ^= x >>> 17;
      x ^= x << 5;
      this.state = x >>> 0;
      return this.state / 0xffffffff;
    }
    range(min, max) {
      return lerp(min, max, this.next());
    }
    pick(list) {
      return list[Math.floor(this.next() * list.length) % list.length];
    }
  }

  const degToRad = (deg) => (deg * Math.PI) / 180;
  const radToDeg = (rad) => (rad * 180) / Math.PI;

  const easing = Object.freeze({
    quadIn: (t) => t * t,
    quadOut: (t) => t * (2 - t),
    quadInOut: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),
    cubicInOut: (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1),
  });

  const vec2 = (x = 0, y = 0) => ({ x, y });
  const vec3 = (x = 0, y = 0, z = 0) => ({ x, y, z });

  const addVec3 = (a, b) => ({ x: a.x + b.x, y: a.y + b.y, z: a.z + b.z });
  const scaleVec3 = (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s });

  const projectPerspective = (z, fov, height) => {
    const halfFov = degToRad(fov / 2);
    return height / Math.tan(halfFov) / z;
  };

  const computeFog = (config, depth) => {
    if (!config.enabled) return 0;
    return clamp((depth - config.nearSegment) / (config.farSegment - config.nearSegment), 0, 1);
  };

  // ---------------------------------------------------------------------------
  // (3) Assets (paths, loader)
  // ---------------------------------------------------------------------------
  const IMAGE_MANIFEST = Object.freeze({
    horizon1: 'tex/paralax-1.png',
    horizon2: 'tex/paralax-2.png',
    horizon3: 'tex/paralax-3.png',
    cliff: 'tex/cliff.png',
    guardrail: 'tex/guardrail.png',
    roadSegment: 'tex/road-seg.png',
    boostJump: 'tex/boost.png',
    boostDrive: 'tex/boost.png',
  });

  const loadImage = (src) => new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });

  async function loadManifest(manifest) {
    const entries = await Promise.all(Object.entries(manifest).map(async ([key, path]) => {
      const image = await loadImage(path);
      return [key, image];
    }));
    return Object.fromEntries(entries);
  }

  // ---------------------------------------------------------------------------
  // (4) World Model (segments, cliffs, sprites, guardrails)
  // ---------------------------------------------------------------------------
  class Segment {
    constructor(index, length, curve, hill, cliff, sprites, boost) {
      this.index = index;
      this.length = length;
      this.curve = curve;
      this.hill = hill;
      this.cliff = cliff;
      this.sprites = sprites;
      this.boost = boost;
      this.startZ = index * length;
      this.endZ = this.startZ + length;
      this.start = vec3(0, 0, this.startZ);
      this.end = vec3(0, 0, this.endZ);
      this.curveOffset = 0;
      this.elevationOffset = 0;
    }
  }

  const createTrack = (segmentsData) => segmentsData.map((data, index) => new Segment(
    index,
    data.length,
    data.curve,
    data.hill,
    data.cliff,
    data.sprites,
    data.boost,
  ));

  class RoadSpline {
    constructor(segments, config) {
      this.segments = segments;
      this.config = config;
      this.segmentLength = config.segmentLengthUnits;
      this.halfWidth = config.roadHalfWidthUnits;
      this.totalSegments = segments.length;
      this.totalLength = this.totalSegments * this.segmentLength;
      this.recomputeGeometry();
    }

    recomputeGeometry() {
      let accumulatedCurve = 0;
      let accumulatedElevation = 0;
      let slope = 0;
      this.segments.forEach((seg) => {
        const { startZ, endZ, curve, hill } = seg;
        seg.start = vec3(accumulatedCurve, accumulatedElevation, startZ);
        slope += hill.rate * this.segmentLength * hill.ease;
        accumulatedElevation += slope;
        accumulatedCurve += curve.rate * this.segmentLength * curve.ease;
        seg.curveOffset = accumulatedCurve;
        seg.elevationOffset = accumulatedElevation;
        seg.end = vec3(accumulatedCurve, accumulatedElevation, endZ);
      });
    }

    locate(z) {
      const wrapped = wrap(z, this.totalLength);
      const index = Math.floor(wrapped / this.segmentLength) % this.totalSegments;
      const seg = this.segments[index];
      const frac = (wrapped - seg.startZ) / this.segmentLength;
      const loop = Math.floor((z - wrapped) / this.totalLength);
      return { seg, index, frac, loop };
    }

    positionAt(z) {
      const { seg, frac, loop } = this.locate(z);
      const x = lerp(seg.start.x, seg.end.x, frac);
      const y = lerp(seg.start.y, seg.end.y, frac);
      const offsetZ = loop * this.totalLength;
      return vec3(x, y, seg.startZ + frac * this.segmentLength + offsetZ);
    }

    curvatureAt(z) {
      const { seg } = this.locate(z);
      return seg.curve.rate;
    }

    elevationAt(z) {
      const { seg, frac } = this.locate(z);
      return lerp(seg.start.y, seg.end.y, frac);
    }

    visibleSegments(z, drawDistance) {
      const out = [];
      let currentZ = z;
      for (let i = 0; i < drawDistance; i += 1) {
        const { seg } = this.locate(currentZ);
        const startPoint = this.positionAt(currentZ);
        const endPoint = this.positionAt(currentZ + this.segmentLength);
        out.push({
          segment: seg,
          startPoint,
          endPoint,
        });
        currentZ += this.segmentLength;
      }
      return out;
    }

    laneAt() {
      return {
        minX: -this.halfWidth,
        maxX: this.halfWidth,
      };
    }

    cliffPushAt(z, x) {
      const { seg } = this.locate(z);
      const { cliff } = seg;
      if (!cliff || cliff.width <= 0) return 0;
      const guardThreshold = this.halfWidth;
      const margin = cliff.width;
      if (x > guardThreshold) {
        return -(x - guardThreshold) / margin;
      }
      if (x < -guardThreshold) {
        return -(x + guardThreshold) / margin;
      }
      return 0;
    }
  }

  const defaultCliff = () => ({ heightLeft: 0, heightRight: 0, width: 0 });

  const createSegmentData = () => ({
    length: TRACK_CONFIG.segmentLengthUnits,
    curve: { rate: 0, ease: 1 },
    hill: { rate: 0, ease: 1 },
    cliff: defaultCliff(),
    sprites: [],
    boost: null,
  });

  const applyCurve = (seg, rate, ease) => ({ ...seg, curve: { rate, ease } });
  const applyHill = (seg, rate, ease) => ({ ...seg, hill: { rate, ease } });
  const applyCliff = (seg, cliff) => ({ ...seg, cliff });
  const attachSprite = (seg, sprite) => ({ ...seg, sprites: [...seg.sprites, sprite] });
  const attachBoost = (seg, boost) => ({ ...seg, boost });

  const repeatSegments = (base, repeat) => {
    const out = [];
    for (let i = 0; i < repeat; i += 1) {
      out.push(...base.map((segment, index) => ({ ...segment, index: out.length + index })));
    }
    return out;
  };

  const generateTrack = () => {
    const base = [];
    for (let i = 0; i < 400; i += 1) {
      let seg = createSegmentData();
      if (i % 20 === 0) {
        seg = applyCurve(seg, Math.sin(i / 10) * 0.5, 0.5);
      }
      if (i % 30 === 0) {
        seg = applyHill(seg, Math.cos(i / 13) * 0.5, 0.5);
      }
      if (i % 40 === 0) {
        seg = applyCliff(seg, { heightLeft: 400, heightRight: 400, width: 800 });
      }
      base.push(seg);
    }
    return createTrack(repeatSegments(base, 2));
  };

  // ---------------------------------------------------------------------------
  // (5) Systems (input, physics, collision, projection)
  // ---------------------------------------------------------------------------
  class InputSystem {
    constructor(config) {
      this.keys = new Map();
      this.actions = new Map();
      Object.entries(config.keyboard).forEach(([action, codes]) => {
        codes.forEach((code) => this.keys.set(code, action));
        this.actions.set(action, false);
      });
    }

    bind() {
      window.addEventListener('keydown', (ev) => this.handle(ev, true));
      window.addEventListener('keyup', (ev) => this.handle(ev, false));
    }

    handle(event, state) {
      const action = this.keys.get(event.code);
      if (!action) return;
      if (state && event.target && event.target.tagName === 'INPUT') return;
      this.actions.set(action, state);
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(event.code)) {
        event.preventDefault();
      }
    }

    pressed(action) {
      return !!this.actions.get(action);
    }

    consume(action) {
      const value = this.actions.get(action);
      this.actions.set(action, false);
      return value;
    }
  }

  class PhysicsSystem {
    constructor(config, driftConfig) {
      this.config = config;
      this.driftConfig = driftConfig;
    }

    update(state, dt) {
      const { car, track } = state;
      const accel = this.resolveAcceleration(state);
      const speedBefore = car.speed;
      car.speed = clamp(car.speed + accel * dt, 0, this.config.maxSpeedUnitsPerSec);
      const drifted = this.updateDrift(state, dt, speedBefore);
      this.integrate(state, dt, drifted);
      this.applyCliffPush(state, dt);
      this.updateHop(state, dt);
      this.resolveFailSafe(state);
    }

    resolveAcceleration(state) {
      const { input, car } = state;
      const throttle = input.pressed('throttle') ? 1 : 0;
      const brake = input.pressed('brake') ? 1 : 0;
      let accel = throttle * this.config.accelUnitsPerSec2 - brake * this.config.brakeUnitsPerSec2;
      if (!car.onGround) {
        accel -= this.config.airDragPerSec * car.speed;
      } else {
        accel -= this.config.rollDragPerSec * car.speed;
      }
      return accel;
    }

    updateDrift(state, dt, speedBefore) {
      const { car, input } = state;
      const steer = (input.pressed('steerRight') ? 1 : 0) - (input.pressed('steerLeft') ? 1 : 0);
      const steerDegPerSec = this.config.steerRateDegPerSec * (car.boostTimer > 0 ? this.driftConfig.boostSteerScale : 1);
      car.headingDegrees += steerDegPerSec * steer * dt;
      car.headingDegrees = wrap(car.headingDegrees, 360);

      if (input.pressed('hop') && car.hopCooldown <= 0) {
        car.verticalSpeed = this.config.hopImpulseUnitsPerSec;
        car.onGround = false;
        car.hopCooldown = this.config.hopCooldownSeconds;
      }

      if (car.boostCharge > 1 && !input.pressed('hop') && car.onGround) {
        car.boostTimer = this.driftConfig.boostTimeSeconds;
        car.boostCharge = 0;
      }

      const centrifugal = Math.abs(steer) * car.speed * this.config.leanFromCentrifugal;
      car.lean = approach(car.lean, centrifugal * (steer >= 0 ? -1 : 1), dt * 2);

      if (car.boostTimer > 0) {
        car.boostTimer = Math.max(0, car.boostTimer - dt);
        car.speed = Math.min(this.config.maxSpeedUnitsPerSec, car.speed * this.driftConfig.boostMultiplier);
      } else if (Math.abs(steer) > 0.5 && car.speed > 0.4 * this.config.maxSpeedUnitsPerSec) {
        car.boostCharge = clamp(car.boostCharge + dt, 0, 1.5);
      } else {
        car.boostCharge = approach(car.boostCharge, 0, dt * 0.5);
      }

      return steer;
    }

    integrate(state, dt, steer) {
      const { track, car } = state;
      const forward = car.speed * dt;
      const curveInfluence = track.curvatureAt(car.positionZ) * forward;
      const roadDrift = steer * forward * 0.0003;
      car.positionZ += forward;
      car.positionX -= curveInfluence;
      car.positionX += roadDrift;
      if (car.positionZ >= track.totalLength) {
        car.positionZ -= track.totalLength;
      }
    }

    applyCliffPush(state, dt) {
      const { car, track } = state;
      const cliffPush = track.cliffPushAt(car.positionZ, car.positionX);
      car.positionX += clamp(cliffPush * TRACK_CONFIG.cliffDistanceGain * dt, -TRACK_CONFIG.cliffCapPerFrame, TRACK_CONFIG.cliffCapPerFrame);
    }

    updateHop(state, dt) {
      const { car } = state;
      if (!car.onGround) {
        car.verticalSpeed -= this.config.gravityUnitsPerSec2 * dt;
        car.positionY += car.verticalSpeed * dt;
        if (car.positionY <= 0) {
          car.positionY = 0;
          car.verticalSpeed = 0;
          car.onGround = true;
        }
      }
      car.hopCooldown = Math.max(0, car.hopCooldown - dt);
    }

    resolveFailSafe(state) {
      const { car } = state;
      if (car.positionY < -TRACK_CONFIG.failSafeBelowRoadUnits) {
        state.resetCar();
      }
    }
  }

  class CollisionSystem {
    constructor(config) {
      this.config = config;
    }

    update(state) {
      const { car, track } = state;
      const lane = track.laneAt(car.positionZ);
      car.positionX = clamp(car.positionX, lane.minX, lane.maxX);
    }
  }

  class ProjectionSystem {
    constructor(config) {
      this.config = config;
    }

    project(world, camera) {
      const depth = world.z - camera.z;
      if (depth <= 0.1) {
        return null;
      }
      const scale = projectPerspective(depth, this.config.cameraFovDegrees, camera.height);
      const screenX = (1 + world.x * scale) * 0.5 * this.config.canvasWidth;
      const screenY = (1 - (world.y - camera.y) * scale) * 0.5 * this.config.canvasHeight;
      return { screenX, screenY, scale, depth };
    }
  }

  class CameraSystem {
    constructor(config) {
      this.config = config;
    }

    update(state, dt) {
      const { car, camera, track } = state;
      const targetZ = car.positionZ - this.config.cameraLookBackSegments * this.config.segmentLengthUnits;
      camera.z = targetZ;
      camera.positionZ = targetZ;
      const roadHeight = track.elevationAt(car.positionZ);
      const targetHeight = roadHeight + this.config.cameraHeightUnits;
      camera.y = approach(camera.y, targetHeight, dt / this.config.cameraHeightLerpTau);
      camera.height = camera.y;
    }
  }

  // ---------------------------------------------------------------------------
  // (6) Rendering (order of operations, batching)
  // ---------------------------------------------------------------------------
  class Renderer {
    constructor(canvas, overlay, hud, assets, config) {
      this.canvas = canvas;
      this.context = canvas.getContext('2d');
      this.overlay = overlay.getContext('2d');
      this.hud = hud.getContext('2d');
      this.assets = assets;
      this.config = config;
    }

    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.overlay.clearRect(0, 0, this.overlay.canvas.width, this.overlay.canvas.height);
      this.hud.clearRect(0, 0, this.hud.canvas.width, this.hud.canvas.height);
    }

    drawScene(state) {
      const { track, car, camera, projection } = state;
      const segments = track.visibleSegments(camera.positionZ, this.config.drawDistanceSegments)
        .sort((a, b) => (b.startPoint.z - camera.z) - (a.startPoint.z - camera.z));
      segments.forEach((data) => this.drawSegment(data, state));
      this.drawCar(state);
    }

    drawSegment(data, state) {
      const { projection, camera, track } = state;
      const p1 = projection.project(data.startPoint, camera);
      const p2 = projection.project(data.endPoint, camera);
      if (!p1 || !p2) return;
      this.context.fillStyle = '#444';
      this.context.beginPath();
      this.context.moveTo(p1.screenX - p1.scale * track.halfWidth, p1.screenY);
      this.context.lineTo(p1.screenX + p1.scale * track.halfWidth, p1.screenY);
      this.context.lineTo(p2.screenX + p2.scale * track.halfWidth, p2.screenY);
      this.context.lineTo(p2.screenX - p2.scale * track.halfWidth, p2.screenY);
      this.context.closePath();
      this.context.fill();
    }

    drawCar(state) {
      const { car } = state;
      this.context.save();
      this.context.fillStyle = 'red';
      this.context.translate(this.canvas.width / 2, this.canvas.height * 0.75);
      this.context.fillRect(-10, -20, 20, 40);
      this.context.restore();
    }

    drawOverlay(state) {
      if (!state.overlayVisible) return;
      const { overlay } = this;
      overlay.save();
      overlay.clearRect(0, 0, overlay.canvas.width, overlay.canvas.height);
      overlay.strokeStyle = 'rgba(255,255,255,0.6)';
      overlay.lineWidth = 2;
      overlay.beginPath();
      const halfWidth = overlay.canvas.width / 2;
      const baseY = overlay.canvas.height * 0.8;
      overlay.moveTo(halfWidth - 200, baseY);
      overlay.lineTo(halfWidth + 200, baseY);
      overlay.stroke();
      const carX = state.car.positionX / state.track.halfWidth;
      overlay.fillStyle = 'rgba(255,64,64,0.8)';
      overlay.beginPath();
      overlay.arc(halfWidth + carX * 180, baseY - 40, 8, 0, TAU);
      overlay.fill();
      overlay.restore();
    }
  }

  // ---------------------------------------------------------------------------
  // (7) Game Loop (update/draw)
  // ---------------------------------------------------------------------------
  class GameState {
    constructor(track, assets) {
      this.track = track;
      this.assets = assets;
      this.car = {
        positionX: 0,
        positionY: 0,
        positionZ: 0,
        verticalSpeed: 0,
        speed: 0,
        headingDegrees: 0,
        lean: 0,
        boostCharge: 0,
        boostTimer: 0,
        onGround: true,
        hopCooldown: 0,
      };
      this.camera = {
        y: TRACK_CONFIG.cameraHeightUnits,
        height: TRACK_CONFIG.cameraHeightUnits,
        z: -TRACK_CONFIG.cameraLookBackSegments * TRACK_CONFIG.segmentLengthUnits,
        positionZ: 0,
      };
      this.overlayVisible = false;
      this.input = new InputSystem(INPUT_CONFIG);
      this.input.bind();
      this.physics = new PhysicsSystem(CAR_CONFIG, DRIFT_CONFIG);
      this.collision = new CollisionSystem(TRACK_CONFIG);
      this.cameraSystem = new CameraSystem(TRACK_CONFIG);
      this.projection = new ProjectionSystem({
        canvasWidth: RENDER_PIPELINE.canvasWidth,
        canvasHeight: RENDER_PIPELINE.canvasHeight,
        cameraFovDegrees: TRACK_CONFIG.cameraFovDegrees,
      });
      this.cameraSystem.update(this, 0);
    }

    resetCar() {
      this.car.positionX = 0;
      this.car.positionY = 0;
      this.car.positionZ = 0;
      this.car.verticalSpeed = 0;
      this.car.speed = 0;
      this.car.headingDegrees = 0;
      this.car.lean = 0;
      this.car.boostCharge = 0;
      this.car.boostTimer = 0;
      this.car.onGround = true;
      this.car.hopCooldown = 0;
      this.camera.y = TRACK_CONFIG.cameraHeightUnits;
      this.camera.height = TRACK_CONFIG.cameraHeightUnits;
      this.camera.z = -TRACK_CONFIG.cameraLookBackSegments * TRACK_CONFIG.segmentLengthUnits;
      this.camera.positionZ = this.camera.z;
      this.cameraSystem.update(this, 0);
    }
  }

  class Game {
    constructor(renderer, state) {
      this.renderer = renderer;
      this.state = state;
      this.lastTime = performance.now();
      this.running = false;
    }

    start() {
      this.running = true;
      requestAnimationFrame((time) => this.step(time));
    }

    step(time) {
      if (!this.running) return;
      const dt = Math.min(0.1, (time - this.lastTime) / 1000);
      this.lastTime = time;
      this.update(dt);
      this.render();
      requestAnimationFrame((t) => this.step(t));
    }

    update(dt) {
      const { state } = this;
      if (state.input.consume('reset')) {
        state.resetCar();
      }
      if (state.input.consume('toggleOverlay')) {
        state.overlayVisible = !state.overlayVisible;
      }
      this.state.physics.update(state, dt);
      this.state.collision.update(state);
      this.state.cameraSystem.update(state, dt);
    }

    render() {
      this.renderer.clear();
      this.renderer.drawScene(this.state);
      this.renderer.drawOverlay(this.state);
    }
  }

  // ---------------------------------------------------------------------------
  // (8) Bootstrapping
  // ---------------------------------------------------------------------------
  async function main() {
    const [mainCanvas, overlayCanvas, hudCanvas] = [
      document.getElementById('outrun'),
      document.getElementById('sideOverlay'),
      document.getElementById('hudMatte'),
    ];

    const assets = await loadManifest(IMAGE_MANIFEST);
    const segments = generateTrack();
    const track = new RoadSpline(segments, TRACK_CONFIG);
    const renderer = new Renderer(mainCanvas, overlayCanvas, hudCanvas, assets, TRACK_CONFIG);
    const state = new GameState(track, assets);
    const game = new Game(renderer, state);
    game.start();
  }

  main();
})();
</script>
</html>
